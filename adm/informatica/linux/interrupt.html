<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interrupt"/>
    <title>Interrupt</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Index</a></li>
    </ul>
</nav>

<div class="content">

<h1>Interrupt</h1>

<p><p>An <b>interrupt</b> is a request for the processor to interrupt currently executing code (when permitted), so that the event can be processed in a timely manner. If the request is accepted, the processor will suspend its current activities, save its state, and execute a function called an interrupt handler (or an interrupt service routine, ISR) to deal with the event. This interruption is often temporary, allowing the software to resume[a] normal activities after the interrupt handler finishes, although the interrupt could instead indicate a fatal error.</p>

<h2>Programmed I/O</h2>

<p>The most basic method of data exchange between a computer and its I/O devices is by executing a program by the CPU in which the CPU takes the direct control of the I/O operations, including sensing device status, issuing read or write command and transferring data. The CPU issues the relevant I/O command and is tied up until the input/output function is finished with the device. Any I/O operation using this method would require that the CPU addresses the device and supervises the device transfer data to or from memory. This method of I/O operation is called <b>programmed I/O</b>.</p>

<h2>Interrupt Drive I/O</h2>

<p>I/O devices are comparitively very slow and may be interrupted now and then by the user. If the CPU has to attend to the device full fime for the data transfer, the CPU's time will be waster. To make better of the situation, the earlier process of I/O programming may be changed. In the changed method, the CPU attends to the device to se if it is ready, gives it the command to perform and se that it has accepted the command and started its operation. Hereafter, the CPU goes bas to doing something else (mostly whatever program it was executing before). The device after getting ready with a byte of data fro transferring, draws the attension of the CPU that it intends to do the data transfer. The CPU comes back to attend the device, takes the data, sends the same to memory and agains goes back to its own work. For every byte of data transfer, this goes on. At the end of transfer of all bytes, CPU and I/O register an end of data transfer with the device. The phenomenon of drawing the attention of the CPU is called <b>Interrupt</b>. As the device interrupts CPU at every byte transfer, this sysmte of I/O programming is called <b>Interrupt Driven I/O</b>.</p>

<p>Interrupt driven 1/0 is more efficient than programmed 1/0 because it eliminates needless waiting of the CPU. However, the CPU is interrupted for every data byte transfer and so a lot of time is still consumed because of I/O interrupt. <br> The interrupt handling within a system is a joint synchronized action of hardware and software as follows:<br> In interrupt I/O, the device interrupts the CPU to inform that it is ready for a data transfer and the CPU should take the data and store into its memory immediately. On getting the interrupt, the CPU, at the end of the current instruction execution acknowledges the interrupt and stores the address of the next instruction, current status and register values onto the control stack in memory to pick those up and resume current job at the end of the interrupt service. In a machine where the program status register (PSW) is used (containing next instruction address, status register, etc.,) the computer stores the PSW onto the stack. The processor loads the new address for servicing the interrupt call.<br>
It is very likely that there will be more than one device connected to a computer system, each having the ability to generate interrupt request. To service the request, the interrupt system requires two informations:</p>

<ul>
	<li><p>Address of the device that interrupted.</p></li>
	<li><p>If more than one device raises interrupt request simultaneously which one to serve first.</p></li>
</ul>

<p>The interrupt service management would also require the ability to disable some of the devices interrupting at certain situations like if a higher priority interrupt is take up for servicing, the lower priority devices may be barred from interrupting till the current service is fulfilled. <br> This is what is known as <b>priority interrupt</b> service.</p>

<p>The priority interrupt mechanism helps in managing the interrupt servicing. Primary purpose of a priority interrupt system is to set priority, <i>i.e.</i> when two or more devices interrupt at the same time, the service management will pick up the device with highest priority for servicing interrupt. Establishing priority may be accomplished by software or hardware. The software process uses a polling procedure to identify the highest priority source interrupting. In this the interrupt service routine, irrespective of the device starts from a common branch address. The software polls the interrupt sources in sequence to see which device has raised the interrupt signal. The order by which the devices are polled (tested) determines the priority. The highest priority device gets tested first. The interrupt service routine branches to a specific device service routine according to the device that has raised the interrupt request signal. After the polling of the first device in the sequence, if the interrupt flag of the device is found not set, the polling is done for the next device in the sequence. Initial routine of the interrupt service program does this polling. The method has a disadvantage in time management. If too many devices are connected and polling is done for all devices one after another, the time to service interrupt will become critical.</p>

<p>An alternative is the hardware method. A hardware priority interrupt may be used to manage an interrupt system environment. The hardware priority interrupt unit receives the interrupt request, determines whch device is higher priority needs service and selects the same for servicing. To speed up further, each interrupting source is given an interrupt vector (memory address where the service routine for that particular device is stored) so that service routine can be directly executes from the address. This will not need any polling because the hardware interrupt management routine will select the address of the interrupt service routine directly.<br> The hardware interrupt priority unit can work with serial or parallel connection of interrupt lines. The serial connection is also called <b>daisy chain connection</b>.</p></p>

<section aria-label="End">
<a href="epoxides.html">&#171;Epoxides</a>
<a href="index.html">Index</a>
<a href="sulfides.html">Sulfides&#187;</a>
</section>

</div>

</body>
</html>
