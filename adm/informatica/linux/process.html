<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Mostrare processi attivi"/>
	<title>Mostrare processi attivi</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>Processes</h1>

<p>A <b>process</b> is a program that's loaded into memroy and run by the CPU. It can be an applications a user interacts withm such a word-processing program or a Web program, or a program with no user interface that communicates with and provides services to other processes. This latter type of processes is usually called a <b>service</b> in Windows and a "daemon" in Linux and is said to tun in the background because there's no user interface. Many TCP/IP Application-layer protocols, such as DNS and DHCP, run as services. Some OSs refer to processes as "<b>tasks</b>".</p>

<p>Operating systems like Linux are designed to allow multiple programs to run at the same time, a capability known as <b>multitasking</b>. In this way, programs take turns using the processor. Multitasking allows a single user to have a spreadsheet and word processor open at the same time. Whether a computer has one or multiple CPUs, it multitasks by using a method called <b>time slicing</b>, which occurs when a CPU's computing cycles are divided between more than one process. Each process receives a limited number processor cycles before the OS suspends it and activates the next process. The act of changing to another process is called <b>context switching</b>.</p>

<p>A <i>program</i> is a static set of statements written by the programmer to perform the computational steps of an algorithm. The OS creates a <i>process</i> for the purpose of running a program. A <b>process</b> is a specific instance of a computer program that is being executed (a program in execution). A process consists of several entities:</p>

<ul>
	<li><p>The executable machine language program;</p></li>
	<li><p>A block of memory, which will include the executable code, a <b>call stack</b> that keeps track of active functions, a <b>heap</b> that can be used for memory explicitly allocated by the user program, and some other memory locations;</p></li>
	<li><p>Descriptors of resources that the OS has allocated to the process, for example file descriptors;</p></li>
	<li><p>Security information − e.g., information specifying which hardware and software resources the process can access</p></li>
	<li><p>Information about the state of the process, such as whether the process is ready to run or is wating on some resource, the content of the registers, and information about the process's memory.</p></li>
</ul>

<p>A <b>thread</b> is the unit of execution of a process, i.e. a subset of a process, designed to be scheduled and executed by the CPU individually of the parent process. Every process has at least one <i>thread</i>. When there are multiple “threads of control” within the same process, we say that the process (or program) is <i>multithreaded</i>. A <b>therad</b> is short for "thread of execution", or a sequence of instructions. A thread is a lighter burden on the OS to create, mantain and manage because very little information is associated with a thread. They are created by process and have their own flow of control and stack. Threads in a OS can be views as <i>lightweight</i> process. As a lightweight, a thread has many properties that a process has: it has an execution path, it can be scheduled, it used resources, etc. With <b>multithreading</b> (multiple threads executed in parallel), a program splits into two or more tasks that run simultaneously. A common use of threads is to have on pay attention to the GUI while others do a long calculation in the background. As a result, the application more readily responds to a user's interaction.</p>

<p>The <b>scheduler</b> forms part of the operating system (or thread library) and it is responsible for allocating processor time to those threads which are currently acrive in the system. A common scheduling policy is simply to cycle through the set of active threads − to prevent a particular thread from monopolizing processor time, the technique of <b>time slicing</b> is usually applied. With time-slicing the scheduler allocates each thread a slice of time (around twenty ms) in whihc to run − at the end of this time-slice the scheduler interrupots the current thread, adds it to the end of a queue and runs another thread from the thead of the queue.</p>

<h1>Mostrare processi attivi</h1>

<p>A child process in Linux is a process created by another process. The parent process is a process that has created one or more child processes on Linux operating system. The process identifier (process ID or PID) is a number used by Linux or Unix operating system kernels. It is used to uniquely identify an active process.</p>

<p>Open the terminal application. Type the <code>pidof</code> command as follows to find PID for firefox process:</p>

<pre>pidof firefox</pre>

<p>Or use the ps command along with grep command as follows:</p>

<pre>ps aux | grep -i firefox</pre>

<p>To look up or signal processes based on name use:</p>

<pre>pgrep firefox</pre>

<h2 id="kill">kill</h2>

<p>If you spend much time as a Linux user or administrator, sooner or later you're going to have to end a process (often simply a program that no longer responds to user input or that just won’t seem to go away). The safest way to kill a process is to simply use the kill command, with no modifiers or flags. First use the ps -ef command to determine the process ID (PID) of the process you want to kill, and then simply type this command:</p>

<pre># kill -pid</pre>

<p>The standard kill command usually works just fine, terminating the offending process and returning its resources to the system. However, if your process has started child processes, simply killing the parent can potentially leave the child processes running, and therefore still consuming system resources. In order to prevent such so-called “zombie processes,” you should make sure that you kill any and all child processes before you kill their respective parent processes.</p>

<p>To find the PID of a certain process, known by name, type</p>

<pre>pgrep -x litos</pre>

<p>without <b>-x</b>, pgrep litos would also match litosapp.</p>

<h2>Killing Processes in the Right Order</h2>

<p>You can identify child process and their parents by using the Linux <code>ps -ef</code> command and examining each entry, looking at the column labeled PPID (parent process ID). However, if you’re only interested in a specific family of processes, using the grep command makes life easier. Let’s look at an example. If we’re trying to kill the <i>httpd</i> process, we’ll need to kill its child processes before we can kill the parent. As a shortcut, use the following command to determine the PIDs that we’ll need to terminate:</p>

<pre># ps -ef | grep httpd
[root@aardvark kida]# ps -ef | grep httpd

root 23739 1 O Junod6 ? 00:00:07 /usr/sbin/httpd

apache 24375 23739 O Jul17 ? 00:00:01 /usr/sbin/httpd

apache 24376 23739 O Jul17 ? 00:00:00 /usr/sbin/httpd

apache 24377 23739 O Juli7 ? 00:00:01 /usr/sbin/httpd

apache 24378 23739 O Jul17 ? 00:00:00 /usr/sbin/httpd

apache 24379 23739 O Juli17 ? 00:00:00 /usr/sbin/httpd

apache 24380 23739 0O Jul17 ? 00:00:01 /usr/sbin/httpd

apache 24383 23739 O Juli7 ? 00:00:00 /usr/sbin/httpd

apache 24384 23739 O Juli17 ? 00:00:01 /usr/sbin/httpd
</pre>

<p>The first column tells us the user that owns each process, and the second and third columns tell us their PIDs and PPIDs, respectively. The first process listed, with the PPID of 1, is the parent process. When a process has a PPID of 1, that means it was started by <i>init</i> at boot time.</p>

<p>The first thing to try now that we have the parent process ID is to try to gracefully take it down by using the following command:</p>

<pre># kill -1 23739</pre>

<p>The -1 option tells the kill command to attempt to end the process as if the user who started it has logged out. When you use this option, the kill command also attempts to go through and kill child processes left behind. This won't always work, though—you may still need to go through and kill child processes manually first, before killing the parent process. To kill more than one process at a time, simply separate the PIDs with spaces on the kill command line:</p>

<pre># kill 24384 24383 24380</pre>

<p>A second option is to send a TERM signal to the parent process in an attempt to kill it and its child processes. This can be done using the following command:</p>

<pre># kill -TERM 23739</pre>

<p>Alternatively, you can attempt to kill all the processes within the same process group using killall. The killall command enables you to specify the names of the processes you want to terminate, rather than their PIDs, which can save you a lot of ps commands and eyestrain:</p>

<pre># killall httpd</pre>

<h2>Stopping and Restarting a Process</h2>

<p>At some point, you might find yourself wanting to simply stop and restart a process. Instead of issuing the sequence of commands to manually kill and then restart your process, try using the following command:</p>

<pre># kill -HUP 23739</pre>

<p>This will have Linux perform the process shutdown gently, and then restart it immediately. This is especially handy when you’re working on configuring an application that needs its process restarted after changes to its configuration files.</p>

<h2>The Last Resort</h2>

<p>If the regular <code>kill</code> or <code>kill -1</code> commands don’t work, you can always bring out the all-powerful <code>kill -9</code> command:</p>

<pre># kill -9 23739</pre>

<p>This extremely powerful and dangerous command forces a process to stop in its tracks, without allowing it to clean up after itself. This can lead to unutilized system resources and is generally not recommended unless all other options have failed.</p>

<p>After using the <code>kill -9</code> (or the synonymous <code>kill -s SIGKILL</code>) command, be sure to use <code>ps -ef</code> again to make sure you don't have any zombie processes left. You can only eliminate a zombie process by terminating its parent process, which is fine if the parent process can safely be terminated or restarted but problematic if the zombie process has ended up being owned by the <i>init</i> process (PID 1). You do <i>not</i> want to kill the <i>init</i> process unless you know its implications and really mean to do that, because killing <i>init</i> will shut down your system. If you have zombie processes whose parent is <i>init</i>, and they are consuming significant amounts of system resources, you will need to reboot the machine at some point in order to clean up the process table.</p>
 
<section aria-label="End">
<a href="comparative_sup.html">&#171; The comparative of superiority</a>
<a href="index.html">Index</a>
<a href="peculiaritiescomp.html">Peculiarities of comparatives and superlatives &#187;</a>
</section>

</div>

</body>
</html>
