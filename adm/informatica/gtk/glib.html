<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="GtkObject">
	<title>GtkObject</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>GtkObject</h1>

<p>The Glib Object System (GObject) was originally a part of the GTK+ library in the form of the <i>GtkObject</i> class. With the release of GTK+2.0, it was moved into its own library, distributed along with Glib. </p>

<p>GObject is part of the GLib library that implements object-oriented extensions for pure C. A similar concept, in addition to GLib itself, is used in projects such as GStreamer, GSettings, ATK, Pango and the entire GNOME project as a whole, as well as in a large number of application applications: GIMP, Inkscape, Geany, Gedit and many others. A large number of programming languages, ranging from mainstream ones such as Python and Java, to finishes like Haskell or D, have bindings to GLib/GTK+, and for a significant number of languages, bindings to GTK + are generally the only way to build a GUI.</p>

<p>Unlike other similar projects, GObject is distinguished by architectural features, the purpose of which is the easy and transparent implementation of library bindings written using pure C and GObject to other programming languages, including dynamic typing and memory management using the garbage collector. This explains some sense of over-complexity that a programmer may have when starting to get to know the GObject API. Nevertheless, this system is very thoughtful and logical, so that a programmer familiar with C ++ or Java should not have problems understanding everything stated below.</p>

<p>This article illustrates the very basics of working with the GLib object system type.</p>

<p>At the most basic level of the GObject type system lies the GType system, which implements a run-time description of all possible types that the programmer operates on. This system acts as a kind of “glue”, linking C code with code in other languages ​​that have bindings to libraries built on the use of a dynamic GLib type system.</p>

<p>The GObject type system supports single inheritance (and taking into account the concept of Java-like interfaces, and more complex conceptual solutions), encapsulation, virtual functions, the so-called properties similar to C++ fields, but with a lot of additional features, as well as a system of signals that allow you to create effective and developed designs within the framework of an event-oriented paradigm.</p>

<p>The GObject type system consists of three main entities - fundamental unmanaged types like gchar (an analog of char from pure C), gpointer (an analog of a pointer of type void), gboolean, etc. the main purpose of overriding these types is unification and portability; instantiable classified types, broadly similar to C ++ classes; and non-instantiable classified types — interfaces similar to Java interfaces or purely abstract C++ classes.</p>

<h2>Naming and conventions</h2>

<p>In general, the program or library that you are working on should have a namespace that is used as the first part of the name of all of the classes that it contains. Gtk uses the prefix Gtk, GLib uses the prefix G, and so on. <br> Following this, you'll need a descriptive name for what the class is doing. This is typically a noun. <br> In our example, we'll assume that our namespace is <i>MyApp</i> and we'll make a class called <i>MyAppWindow</i> which is a subclass of <i>GtkApplicationWindow</i>.</p>

<p>When you define a class, it is expected that you will also define some additional standard macros that are used with that class. These macros are available for all object types. In our case these would be:</p>

<ul>
	<li><p><i>MY_APP_TYPE_WINDOW</i> — a macro that evaluates to the GType of your new object type</p></li>

	<li><p><i>MY_APP_WINDOW</i> — a type-checking macro that casts GObject instances to your pointer type</p></li>

	<li><p><i>MY_APP_IS_WINDOW</i> — a macro for checking if a given GObject is an instance of your object type derivable classes will also contain other macros to help with further subclassing them all methods related to your class should have names starting with</p></li>
</ul>

<div class="eq">
<p><code>my_app_window_ </code> as a way to distinguish them from methods of other classes a constructor function (my_app_window_new) will typically be provided</p>
</div>

<p>Most of the above macros will be written for you automatically if you follow the templates below. </p>

<pre>
/* my-app-window.h:
 * Copyright YEAR Copyright Holder
 *
 * Licence text goes here
 *
 * Author: you &lt;your@email&gt;
 */

/*Don't redifine things that you not redifine */

#ifndef _my_app_window_h_
#define _my_app_window_h_
/* Alternatively to the following you can use #pragma once */


G_BEGIN_DECLS

/* Type declaration */

#define MY_APP_TYPE_WINDOW (my_app_window_get_type ())
G_DECLARE_FINAL_TYPE(MyAppWindow, my_app_window, MY_APP, WINDOW, GtkApplicationWindow)

/* Method declaration */

MyAppWindow *          my_app_window_new            (void);

G_END_DECLS

#endif /* _my_app_window_h_ */

my-app-window.c:

/* Copyright YEAR Copyright Holder
 *
 * Licence text goes here
 *
 * Author: you &lt;your@email&gt;
 */

#include "my-app-window.h"

struct _MyAppWindow
{
  GtkApplicationWindow parent_instance;

  // instance variables for subclass go here
};

G_DEFINE_TYPE(MyAppWindow, my_app_window, GTK_TYPE_APPLICATION_WINDOW)

static void
my_app_window_init (MyAppWindow *window)
{
  // initialisation goes here
}

static void
my_app_window_class_init (MyAppWindowClass *class)
{
  // virtual function overrides go here
  // property and signal definitions go here
}

MyAppWindow *
my_app_window_new (void)
{
  return g_object_new (MY_APP_TYPE_WINDOW, NULL);
}
</pre>

<p>The <i>G_DECLARE_FINAL_TYPE</i> macro takes your C structure name (<i>MyAppWindow</i>), the uppercase namespace name of your project (<i>MY_APP</i>), the uppercase name of your class (<i>WINDOW</i>), the lowercase prefix of your C functions (<i>my_app_window</i>) and the class name of your parent class (GtkApplicationWindow). These names are used to create the various macros that are expected to exist for your type, as well as defining its "Class" structure. </p>

<h2>Example</h2>

<p>Let's try to write a simple example demonstrating the operation of the GObject library. First, let's get acquainted with the main conventions adopted among developers using GLib. The name of any object has a generic name - a kind of namespace, and a species. For example, all objects present in the GLib library have the prefix “G”, GTK + objects have the prefix “Gtk”. The names of objects are written in "camel" notation, and the names of function-methods related to these objects in "snake". Macros are traditionally written in uppercase, words are separated by underscores. For example, AnimalCat is a Cat object belonging to the Animal namespace, and its “methods” will look like animal_cat_say_meow ().</p>

<p>Let's create two files describing our new cat object - <i>animalcat.c</i> and <i>animalcat.h</i>. Add protection against repeated inclusion in the header file and connect the GObject library:</p>

<pre>
#ifndef _ANIMAL_CAT_H_
#define _ANIMAL_CAT_H_
#include 
</pre>

<p>We add two traditional macros that are used in GLib for compatibility with C++ compilers and close protection against re-inclusion:</p>

<pre>
G_BEGIN_DECLS
/* все наши дальнейшие определения будут тут */ 
G_END_DECLS
#endif /* _ANIMAL_CAT_H_ */
</pre>

<p>We add the two most important definitions that will be needed in our header file. The first macro has the form:</p>

<pre>#define OURNAMESPACE_TYPE_OUROBJECT ournamespace_ourobject_get_type()</pre>

<p>that is, in our particular case:</p>

<pre>#define ANIMAL_TYPE_CAT animal_cat_get_type()</pre>

<p>This function returns a GType structure containing all the basic information about the type - name, amount of memory required by the object, links to the initialization and finalization functions of the class and object (analogues of C++ constructors and destructors), etc. The second macro looks like this:</p>

<pre>G_DECARE_DERIVABLE_TYPE (NamespaceObject, namespace_object, NAMESPACE, OBJECT, ParentClass)</pre>

<p>and in our case:</p>

<pre>G_DECLARE_DERIVABLE_TYPE (AnimalCat, animal_cat, ANIMAL, CAT, GObject)</pre>

<p>This macro definition is decomposed into a whole set of important macros that perform type conversion, checking for membership in a particular type, etc. In the last argument, GObject is declared as the parent class, from which all objects of the GObject type system are inherited. <br> In fact, any GObject or object inherited from it consists of two structures: _NamespaceObject and _NamespaceObjectClass, in our case:</p>

<pre>
struct _AnimalCat
struct _AnimalCatClass
</pre>

<p>We agree to call them the actual object and class. In current versions of GObject, in general, there is no need to implement the object structure in an explicit form, often it is automatically generated as a result of expanding the macro. A class must be implemented explicitly if our goal is to build an inheritance hierarchy with redefinition of virtual functions.</p>

<p>GObjects are of two types, differing in the possibility of inheritance - derivable and final. In the second case, the last macro would look like G_DECLARE_FINAL_TYPE, and the _NamespaceObject structure would have to be declared explicitly in the .c file. In the case of a derivable object, you do not need to declare this structure; it is generated automatically when the macro expands.</p>

<p>We describe the structure of <code>_AnimalCatClass</code>. This structure exists in a single copy, it is created during the creation of the first instance of our facility, and is destroyed after the destruction of the last instance. As the first field, it should contain the same structure of the parent class, in our case GObject, since we inherit directly from it. After that, there are other fields, mainly pointers to functions that implement the functionality of virtual methods, as well as fields similar to static fields of C ++ classes.</p>

<p>For example, the <code>_AnimalCatClass</code> class might look like this:</p>

<pre>
struct _AnimalCatClass
{
	GObjectClass parent_class;
	void (*say_meow)(AnimalCat*);
};
</pre>

<p>We supplement the header file with declarations of specific methods. Objects inherited from GObject are created by code that, in its simplest form, looks like this:</p>

<pre>g_object_new(NAMESPACE_TYPE_OBJECT, NULL);</pre>

<p>It is customary to wrap a similar code in a function of the form:</p>

<pre>
AnimalCat* 
animal_cat_new();
</pre>

<p>We conclude the header file with the declaration of a specific method:</p>

<pre>
void 
animal_cat_say_meow(AnimalCat* self);
</pre>

<p>As we can see, unlike languages ​​like C ++, in this case we need to explicitly pass a pointer to a specific instance. So, the header file now looks like this:</p>

<pre>
#ifndef _ANIMAL_CAT_H_
#define _ANIMAL_CAT_H_
#include 
G_BEGIN_DECLS
#define ANIMAL_TYPE_CAT animal_cat_get_type()
G_DECLARE_DERIVABLE_TYPE (AnimalCat, animal_cat, ANIMAL, CAT, GObject) 
struct _AnimalCatClass
{
	GObjectClass parent_class;
	void (*say_meow) (AnimalCat*);
};
AnimalCat* 
animal_cat_new();
void 
animal_cat_say_meow(AnimalCat* self);
G_END_DECLS
#endif /* _ANIMAL_CAT_H_ */
</pre>

<p>Let's move on to the file with the source code itself. We include our header file, as well as stdio.h, which is necessary for meowing our sample.</p>

<pre>
#include 
#include "animalcat.h"
</pre>

<p>It is time for another important macro, which this time looks like this:</p>

<pre>G_DEFINE_TYPE (NamespaceObject, namespace_object, G_TYPE_OBJECT)</pre>

<p>The last argument we pass to the macro is similar to the one we defined at the beginning of our header file, relevant for the parent object. For our cat-object, it should look like ANIMAL_TYPE_CAT, but in this case we use a similar macro to our parent object: G_TYPE_OBJECT. In relation to our situation, this line should look like this:</p>

<pre>G_DEFINE_TYPE (AnimalCat, animal_cat, G_TYPE_OBJECT)</pre>

<p>Remember, a little earlier we talked about the difference between derivable and final-gobject? If we defined a final object that does not imply the possibility of inheriting from it, then we would have to define a structure</p>

<pre>
struct _NamespaceObject
{
	ParentObject parent;
};</pre>

<p>which must contain at least one field (and certainly the first) - a similar structure to the parent object. Such mandatory requirements are related to the fact that the address of the pointer to the structure of the parent object must be identical to the addresses of the pointers to the structures of all the objects inherited from it. <br> In our case, the structure would look at least like this:</p>

<pre>
struct _AnimalCat
{
	GObject parent;
};
</pre>

<p>Let me remind you once again - to explicitly define this structure is only necessary if GObject is of type final, and in our example we omit this definition. <br> We proceed directly to the executable code. We define an <code>animal_cat_say_meow ()</code> function to demonstrate how the virtual function mechanism works in GObject (a little later you will see why this is needed).</p>

<pre>
static void
animal_cat_real_say_meow(AnimalCat* self)
{
	printf("Cat say: MEOW!\n");
}
</pre>

<p>We also define the actually called method that was declared in the header file:</p>

<pre>
void 
animal_cat_say_meow(AnimalCat* self)
{
	AnimalCatClass* klass = ANIMAL_CAT_GET_CLASS (self);
	klass->say_meow(self);
}
</pre>

<p>The following two important functions are called automatically - the first when creating the first instance of this object, the second - when creating any specific instance, thus being, in a sense, an analogue of the C++ constructor.</p>

<pre>static void
animal_cat_class_init(AnimalCatClass* self)
{
	printf("First instance of AnimalCat was created\n");
	self->say_meow = animal_cat_real_say_meow;
}</pre>

<p>As you can see, we redefined the “virtual” function defined in the structure-class of our object.</p>

<p>What happens in the code described above? In the <code>animal_cat_class_init ()</code> function, when initializing the class structure of our object, the say_meow function reference is assigned the address of the <code>animal_cat_real_say_meow ()</code> function, after which, when the <code>animal_cat_say_meow ()</code> function is called using the ANIMAL_CAT_GET_CLASS macro, we get a pointer to the class structure of our object and call the function whose address is currently assigned to the say_meow field in the AnimalCatClass structure. In successor objects, we can override this behavior in the corresponding function, whose name ends with class_init.</p>

<p>Let's proceed to the "constructor":</p>

<pre>
static void
animal_cat_init(AnimalCat* self)
{
	printf("Kitty was born.\n");
}
</pre>

<p>Let's create a wrapper function that will return a pointer to a new instance of the AnimalCat object:</p>

<pre>
AnimalCat*
animal_cat_new()
{
	return g_object_new(ANIMAL_TYPE_CAT, NULL);
}
</pre>

<p>We write a simple <code>main ()</code> function to test the health of our code:</p>

<pre>
#include «animalcat.h"
int 
main(int argc, char** argv)
{
	AnimalCat* cat_a = animal_cat_new();
	AnimalCat* cat_b = animal_cat_new();
	animal_cat_say_meow(cat_a);
	return 0;
}
</pre>

<p>and makefile:</p>

<pre>
CFLAGS = -Wall -g `pkg-config --cflags glib-2.0 gobject-2.0`
LDFLAGS = `pkg-config --libs glib-2.0 gobject-2.0`
EXEC =  kitty
SRC =  main.c animalcat.c animalcat.c
OBJ =  main.o animalcat.o animalcat.o
$(EXEC): $(OBJ)
	 $(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)
%.o: %.c
	 $(CC) -c -o $@ $< $(CFLAGS)
.PHONY: clean
clean:
	 rm -f $(OBJ) $(EXEC)
</pre>

<p>We collect and run:</p>

<pre>
make
./kitty

First instance of AnimalCat was created.
Kitty was born.
Kitty was born.
Cat say: MEOW!
</pre>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="hello_world.html">Hello World &#187;</a>
</section>

</article>

</body>
</html>
