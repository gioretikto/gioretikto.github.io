<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Widget Hierarchy"/>
    <title>Widget Hierarchy</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Index</a></li>
    </ul>
</nav>

<div class="content">

<h1>Widget Hierarchy</h1>

<p>Widgets in GTK+ use the GObject hierarchy system, which allows you to derive new widgets from those that already exist. Child widgets inherit properties, functions, and signals from their parent, their grandparent, and so on, because they are actually implementations of their ancestors themselves. Widget hierarchy in GTK+ is a singly inherited system, which means that each child can have only one direct parent. This creates a simple linear relationship that every widget implements. You will learn how to derive your own child widgets in Chapter 11. Until then, we will use widget hierarchy to take advantage of inherited methods and properties.</p>

<p>Widgets in GTK+ use the GObject hierarchy system, which allows you to derive new widgets from those that already exist. Child widgets inherit properties, functions, and signals from their parent, their grandparent, and so on, because they are actually implementations of their ancestors themselves. The following is a the widget hierarchy of GtkWindow</p>

<pre>
    GObject
    	├── GInitiallyUnowned
    	      ├── GtkWidget
    		      ├── GtkContainer
			     ├── GtkBin
    				    ├── GtkWindow
</pre>

<ul>
	<li><p><i>GObject</i> is the fundamental type providing common attributes for all libraries based on it including GTK+ and Pango. It allows objects derived from it to be constructed, destroyed, referenced, and unreferenced. It also provides the signal system and object property functions. You can cast an object as a GObject with G_OBJECT() . If you try to cast an object with G_OBJECT() that is not a GObject or derived from it, GLib will throw a critical error, and the cast will fail. This will occur with any other GTK+ casting function.</p></li>

	<li><p><i>GInitiallyUnowned</i> should never be accessed by the programmer, since all of its members are private. It exists so that references can be floating. A floating reference is one that is not owned by anyone.</p></li>

	<li><p><i>GtkObject</i> is the base class for all GTK+ objects. It was replaced as the absolute base class of all objects in GTK+ 2.0, but GtkObject was kept for backward compatibility of	nonwidget classes like GtkAdjustment . You can cast an object as a GtkObject with	GTK_OBJECT().</p></li>

	<li><p><i>GtkWidget</i> is an abstract base class for all GTK+ widgets. It introduces style properties and standard functions that are needed by all widgets. The standard practice is to store all widgets as a GtkWidget , which can be seen in Listing 2-1. Therefore, you will rarely need to use GTK_WIDGET() to cast an object.</p></li>

	<li><p><i>GtkContainer</i> is an abstract class that is used to contain one or more widgets. It is an extremely important structure, since you could not add any other widgets to a window without it. Therefore, the whole of Chapter 3 is dedicated to widgets derived from this class. You can cast an object as a GtkContainer with GTK_CONTAINER().</p></li>

	<li><p><i>GtkBin</i> is another abstract class that allows a widget to contain only one child. It allows multiple widgets to have this functionality without the need for reproduction of code.	You can cast an object as a GtkBin with GTK_BIN().</p></li>

	<li><p><i>GtkWindow</i> is the standard window object you saw in the "Hello world program". You can use GTK_WINDOW() to cast an object.</p></li>
</ul>

<p>Wikipedia defines a Widget as "A control element (sometimes called a control or widget) in a graphical user interface is an element of interaction, such as a button or a scroll bar. " In GTK+ the GtkWidget class is the staring point for all of the available controls.</p>

<p>A widget that can hold other widgets is called a "container" and is of type GtkContainer. The most obvious example of a container is an application's window. If a GtkWindow is not contained in any other GtkWidget it is called a "top level window". Top level windows interact with the desktop window manager which controls where the window is placed on the desk top and then adds window decorations such as a "Title Bar" which typically contains buttons to hide,maximise and close the window. A window with no child widgets is just a blank rectangle (as shown below).</p>

<p>Although GTK+ is written in C (Not C++) it uses an object oriented framework provided by the glib GObject library. </p>

<p>For historical reasons, a lot of widget constructors return <i>GtkWidget</i> instead of the type they are constructing; take a look at <code>gtk_window_new()</code>, the function used to create a new GtkWindow object. You will notice in the following line that, while we want to create a new GtkWindow, <code>gtk_window_new()</code> returns a pointer to a <i>GtkWidget</i>. This is because every widget in GTK+ is actually a GtkWidget itself.</p>

<h3>Casting</h3>

<p>A window title is set using gtk_window_set_title(). This function takes a GtkWindow pointer and a string as input. As our window pointer is a GtkWidget pointer, we need to cast it to GtkWindow. But instead of casting window via the usual C cast operator (GtkWindow *), window should be cast using the GTK_WINDOW() macro. GTK_WINDOW() will perform a run time check if the pointer is an instance of the GtkWindow class, before casting, and emit a warning if the check fails.</p>

<pre>gtk_window_set_title (GTK_WINDOW (window), "Hello World"); </pre>

As you can in the class hierarchy, all GtkWidgets are derived from the GObject base class. This means you can use a widget in any place the function asks for an object - simply use the G_OBJECT() macro.
For example:

<pre>g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(callback_function),callback_data);</pre>

<p>This casts the button into an object, and provides a cast for the function pointer to the callback. Many widgets are also containers. If you look in the class hierarchy below, you'll notice that many
widgets derive from the Container class. Any one of these widgets may be used with the GTK_CONTAINER macro to pass them to functions that ask for containers.</p>

<pre>gtk_container_set_border_width(GTK_CONTAINER(window), 10);<pre>

<pre>GtkWidget* gtk_window_new (GtkWindowType type);</pre>

<section aria-label="End">
<a href="signals_callbacks.html">&#171;Signal and Callbacks</a>
<a href="index.html">Index</a>
<a href="hello_world.html">Hello World &#187;</a>
</section>

</div>

</body>
</html>
