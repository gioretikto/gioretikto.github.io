<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="GtkBuilder class"/>
	<title>GtkBuilder class</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Index</a></li>
		<li><a class="navbar" href="../../index.html">Documentation</a></li>
	</ul>
</nav>
      
<article>

<h1>GtkBuilder class</h1>

<p>When construcing a more complicated user interface, with dozens or hundreds of widgets, doing all the setup work in C code is cumbersome, and making changes becomes next to impossible. <br> Thankfully, GTK+ supports the separation of user interface layout from your business logic, by using UI descriptions in an XML format that can be parsed by the <code>GtkBuilder</code> class.</p>

<pre>#include &ltgtk/gtk.h&gt

static void
print_hello (GtkWidget *widget,
             gpointer   data)
{
  g_print ("Hello World\n");
}

int
main (int   argc,
      char *argv[])
{
  GtkBuilder *builder;
  GObject *window;
  GObject *button;
  GError *error = NULL;

  gtk_init (&argc, &argv);

  /* Construct a GtkBuilder instance and load our UI description */
  builder = gtk_builder_new ();
  if (gtk_builder_add_from_file (builder, "builder.ui", &error) == 0)
    {
      g_printerr ("Error loading file: %s\n", error->message);
      g_clear_error (&error);
      return 1;
    }

  /* Connect signal handlers to the constructed widgets. */
  window = gtk_builder_get_object (builder, "window");
  g_signal_connect (window, "destroy", G_CALLBACK (gtk_main_quit), NULL);

  button = gtk_builder_get_object (builder, "button1");
  g_signal_connect (button, "clicked", G_CALLBACK (print_hello), NULL);

  button = gtk_builder_get_object (builder, "button2");
  g_signal_connect (button, "clicked", G_CALLBACK (print_hello), NULL);

  button = gtk_builder_get_object (builder, "quit");
  g_signal_connect (button, "clicked", G_CALLBACK (gtk_main_quit), NULL);

  gtk_main ();

  return 0;
}
</pre>

<p>Create a new file with the following content named builder.ui.</p>

<pre>
&lt;interface&gt;
  &lt;object id="window" class="GtkWindow"&gt;
    &lt;property name="visible"&gt;True&lt;/property&gt;
    &lt;property name="title"&gt;Grid&lt;/property&gt;
    &lt;property name="border-width"&gt;10&lt;/property&gt;
    &lt;child&gt;
      &lt;object id="grid" class="GtkGrid"&gt;
        &lt;property name="visible"&gt;True&lt;/property&gt;
        &lt;child&gt;
          &lt;object id="button1" class="GtkButton"&gt;
            &lt;property name="visible"&gt;True&lt;/property&gt;
            &lt;property name="label"&gt;Button 1&lt;/property&gt;
          &lt;/object&gt;
          &lt;packing&gt;
            &lt;property name="left-attach"&gt;0&lt;/property&gt;
            &lt;property name="top-attach"&gt;0&lt;/property&gt;
          &lt;/packing&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object id="button2" class="GtkButton"&gt;
            &lt;property name="visible"&gt;True&lt;/property&gt;
            &lt;property name="label"&gt;Button 2&lt;/property&gt;
          &lt;/object&gt;
          &lt;packing&gt;
            &lt;property name="left-attach"&gt;1&lt;/property&gt;
            &lt;property name="top-attach"&gt;0&lt;/property&gt;
          &lt;/packing&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object id="quit" class="GtkButton"&gt;
            &lt;property name="visible"&gt;True&lt;/property&gt;
            &lt;property name="label"&gt;Quit&lt;/property&gt;
          &lt;/object&gt;
          &lt;packing&gt;
            &lt;property name="left-attach"&gt;0&lt;/property&gt;
            &lt;property name="top-attach"&gt;1&lt;/property&gt;
            &lt;property name="width"&gt;2&lt;/property&gt;
          &lt;/packing&gt;
        &lt;/child&gt;
      &lt;/object&gt;
      &lt;packing&gt;
      &lt;/packing&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</pre>

<p>By looking closely at the XML text, we can see that the &lt;object&gt; elements describe a Gtk.ApplicationWindow widget containing a GtkLabel showing a short text message. Child elements of these, such as &lt;property&gt; describe how each widget is configured.</p>

<p>GtkBuildable interface supports adding children at the start or end sides by specifying “<b>start</b>” or “<b>end</b>” as the “<b>type</b>” attribute of a &lt;child&gt; element,</p>

<pre>&lt;child type="start"&gt;</pre>

<p>Note the id property on the object describing the Gtk.ApplicationWindow widget:</p>

<pre> &lt;object class="GtkApplicationWindow" id="window"&gt;</pre>

<p>The id attribute allows the application code to refer to specific widgets. In this case, the main window of the application can be referred to using the window identifier.</p>


<p>You can compile the program above with GCC using:</p>

<pre>gcc `pkg-config --cflags gtk+-3.0` -o example-3 example-3.c `pkg-config --libs gtk+-3.0`</pre>
      
<p>Note that GtkBuilder can also be used to construct objects that are not widgets, such as tree models, adjustments, etc. That is the reason the method we use here is called <code>gtk_builder_get_object()</code> and returns a GObject* instead of a GtkWidget*.</p>

<p>Normally, you would pass a full path to <code>gtk_builder_add_from_file()</code> to make the execution of your program independent of the current directory. A common location to install UI descriptions and similar data is /usr/share/appname.</p>

<p>It is also possible to embed the UI description in the source code as a string and use <code>gtk_builder_add_from_string()</code> to load it. But keeping the UI description in a separate file has several advantages: It is then possible to make minor adjustments to the UI without recompiling your program, and, more importantly, graphical UI editors such as glade can load the file and allow you to create and modify your UI by point-and-click.</p>

<h2>Description</h2>

<p>A GtkBuilder is an auxiliary object that reads textual descriptions of a user interface and instantiates the described objects. To create a GtkBuilder from a user interface description, call gtk_builder_new_from_file(), gtk_builder_new_from_resource() or gtk_builder_new_from_string().</p>

<p>In the (unusual) case that you want to add user interface descriptions from multiple sources to the same GtkBuilder you can call gtk_builder_new() to get an empty builder and populate it by (multiple) calls to gtk_builder_add_from_file(), gtk_builder_add_from_resource() or gtk_builder_add_from_string().</p>

<p>A GtkBuilder holds a reference to all objects that it has constructed and drops these references when it is finalized. This finalization can cause the destruction of non-widget objects or widgets which are not contained in a toplevel window. For toplevel windows constructed by a builder, it is the responsibility of the user to call gtk_widget_destroy() to get rid of them and all the widgets they contain.</p>

<p>The functions gtk_builder_get_object() and gtk_builder_get_objects() can be used to access the widgets in the interface by the names assigned to them inside the UI description. Toplevel windows returned by these functions will stay around until the user explicitly destroys them with gtk_widget_destroy(). Other widgets will either be part of a larger hierarchy constructed by the builder (in which case you should not have to worry about their lifecycle), or without a parent, in which case they have to be added to some container to make use of them. Non-widget objects need to be reffed with g_object_ref() to keep them beyond the lifespan of the builder.</p>

<p>The function gtk_builder_connect_signals() and variants thereof can be used to connect handlers to the named signals in the description.
GtkBuilder UI Definitions</p>

<p>GtkBuilder parses textual descriptions of user interfaces which are specified in an XML format which can be roughly described by the RELAX NG schema below. We refer to these descriptions as “GtkBuilder UI definitions” or just “UI definitions” if the context is clear. Do not confuse GtkBuilder UI Definitions with GtkUIManager UI Definitions, which are more limited in scope. It is common to use .ui as the filename extension for files containing GtkBuilder UI definitions.</p>

<h2>RELAX NG Compact Syntax</h2>

<p>The toplevel element is &lt;interface&gt;. It optionally takes a “domain” attribute, which will make the builder look for translated strings
using <code class="function">dgettext()</code> in the domain specified. This can also be done by calling <a class="link" href="GtkBuilder.html#gtk-builder-set-translation-domain" title="gtk_builder_set_translation_domain&nbsp;()"><code class="function">gtk_builder_set_translation_domain()</code></a> on the builder. Objects are described by &lt;object&gt; elements, which can contain &lt;property&gt; elements to set properties, &lt;signal&gt; elements which
connect signals to handlers, and &lt;child&gt; elements, which describe child objects (most often widgets inside a container, but also e.g. actions in an action group, or columns in a tree model). A &lt;child&gt; element contains an &lt;object&gt; element which describes the child object. The target toolkit version(s) are described by &lt;requires&gt; elements, the “lib” attribute specifies the widget library in question (currently the only supported value is “gtk+”) and the “version” attribute specifies the target version in the form “&lt;major&gt;.&lt;minor&gt;”. The builder will error out if the version requirements are not met.</p> <p>Typically, the specific kind of object represented by an &lt;object&gt; element is specified by the “class” attribute. If the type has not been loaded yet, GTK+ tries to find the <code class="function">get_type()</code> function from the class name by applying heuristics. This works in most cases, but if necessary, it is possible to specify the name of the <code class="function">get_type()</code> function explictly with the "type-func" attribute. As a special case, GtkBuilder allows to use an object that has been constructed by a <a class="link" href="GtkUIManager.html" title="GtkUIManager"><span class="type">GtkUIManager</span></a> in another part of the UI definition by specifying the id of the <a class="link" href="GtkUIManager.html" title="GtkUIManager"><span class="type">GtkUIManager</span></a> in the “constructor” attribute and the name of the object in the “id” attribute.</p> 

<p>Objects may be given a name with the “id” attribute, which allows the application to retrieve them from the builder with <a class="link" href="GtkBuilder.html#gtk-builder-get-object" title="gtk_builder_get_object&nbsp;()"><code class="function">gtk_builder_get_object()</code></a>.
An id is also necessary to use the object as property value in other parts of the UI definition. GTK+ reserves ids starting and ending
with ___ (3 underscores) for its own purposes.</p> 

<p>Setting properties of objects is pretty straightforward with the &lt;property&gt; element: the “name” attribute specifies the name of the
property, and the content of the element specifies the value. If the “translatable” attribute is set to a true value, GTK+ uses
<code class="function">gettext()</code> (or <code class="function">dgettext()</code> if the builder has a translation domain set)
to find a translation for the value. This happens before the value
is parsed, so it can be used for properties of any type, but it is
probably most useful for string properties. It is also possible to
specify a context to disambiguate short strings, and comments which
may help the translators.</p>
<p>GtkBuilder can parse textual representations for the most common
property types: characters, strings, integers, floating-point numbers,
booleans (strings like “TRUE”, “t”, “yes”, “y”, “1” are interpreted
as <code class="literal">TRUE</code>, strings like “FALSE”, “f”, “no”, “n”, “0” are interpreted
as <code class="literal">FALSE</code>), enumerations (can be specified by their name, nick or
integer value), flags (can be specified by their name, nick, integer
value, optionally combined with “|”, e.g. “GTK_VISIBLE|GTK_REALIZED”)
and colors (in a format understood by <code class="function">gdk_rgba_parse()</code>).</p>
<p>GVariants can be specified in the format understood by <code class="function">g_variant_parse()</code>,
and pixbufs can be specified as a filename of an image file to load.</p>
<p>Objects can be referred to by their name and by default refer to
objects declared in the local xml fragment and objects exposed via
<a class="link" href="GtkBuilder.html#gtk-builder-expose-object" title="gtk_builder_expose_object&nbsp;()"><code class="function">gtk_builder_expose_object()</code></a>. In general, GtkBuilder allows forward
references to objects — declared in the local xml; an object doesn’t
have to be constructed before it can be referred to. The exception
to this rule is that an object has to be constructed before it can
be used as the value of a construct-only property.</p>

<p>It is also possible to bind a property value to another object's
property value using the attributes
"bind-source" to specify the source object of the binding,
"bind-property" to specify the source property and optionally
"bind-flags" to specify the binding flags
Internally builder implement this using GBinding objects.
For more information see <code class="function">g_object_bind_property()</code></p>
<p>Signal handlers are set up with the &lt;signal&gt; element. The “name”
attribute specifies the name of the signal, and the “handler” attribute
specifies the function to connect to the signal. By default, GTK+ tries
to find the handler using <code class="function">g_module_symbol()</code>, but this can be changed by
passing a custom <a class="link" href="GtkBuilder.html#GtkBuilderConnectFunc" title="GtkBuilderConnectFunc&nbsp;()"><span class="type">GtkBuilderConnectFunc</span></a> to
<a class="link" href="GtkBuilder.html#gtk-builder-connect-signals-full" title="gtk_builder_connect_signals_full&nbsp;()"><code class="function">gtk_builder_connect_signals_full()</code></a>. The remaining attributes, “after”,
“swapped” and “object”, have the same meaning as the corresponding
parameters of the <code class="function">g_signal_connect_object()</code> or
<code class="function">g_signal_connect_data()</code> functions. A “last_modification_time”
attribute is also allowed, but it does not have a meaning to the
builder.</p>
<p>Sometimes it is necessary to refer to widgets which have implicitly
been constructed by GTK+ as part of a composite widget, to set
properties on them or to add further children (e.g. the <em class="parameter"><code>vbox</code></em>
 of
a <a class="link" href="GtkDialog.html" title="GtkDialog"><span class="type">GtkDialog</span></a>). This can be achieved by setting the “internal-child”
propery of the &lt;child&gt; element to a true value. Note that GtkBuilder
still requires an &lt;object&gt; element for the internal child, even if it
has already been constructed.</p>
<p>A number of widgets have different places where a child can be added
(e.g. tabs vs. page content in notebooks). This can be reflected in
a UI definition by specifying the “type” attribute on a &lt;child&gt;
The possible values for the “type” attribute are described in the
sections describing the widget-specific portions of UI definitions.</p>

<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="hello_world.html">Hello World &#187;</a>
</section>

</article>

</body>
</html>
