<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Signals and Callbacks"/>
	<title>Signals and Callbacks</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">index</a></li>
	</ul>
</nav>

<article>

<h1>Signals and Callbacks</h1>

<p>In GTK+ an <b>event</b> is a message from the X server. When the event reaches a widget, it may react to this event by emitting a <b>signal</b>. The GTK+ programmer can connect a specific callback to the signal. The <b>callback</b> is a handler function that reacts to the signal</p>
 
<p>The first instance of an event you encountered was <i>delete-event</i>. The <i>delete-event</i> signal is emitted when the user tries to close the window. The window can be exited by clicking the close button on the title bar, using the close pop-up menu item in the taskbar, or by any other means provided by the window manager.</p>

<p>In this part of the GTK+ programming tutorial, we talk about the event system.</p>

<p>GTK+ is an event driven system. All GUI applications are event driven. The applications start a main loop, which continuously checks for newly generated events. If there is no event, the application waits and does nothing. In GTK+ an event is a message from the X server. When the event reaches a widget, it may react to this event by emitting a signal. The GTK+ programmer can connect a specific callback to the signal. The callback is a handler function that reacts to the signal.</p>

<h2>Connecting the Signal</h2>

<p>In the documentation you find all signals related to a particular widget, for example for GtkButtons, the signals are:</p>

<img src="img/GtkButton_signals.png" alt="GtkButton signals"/>

<pre>GtkWidget *button;
  button = gtk_button_new_with_label ("Hello World");
g_signal_connect (button, "clicked", G_CALLBACK (print_hello), NULL);</pre>

<p>The GtkWindow was connected to the <code>destroy()</code> callback function in the previous examples. This function will be called when the destroy signal is emitted.</p>

<pre> g_signal_connect (G_OBJECT (window), "destroy",
G_CALLBACK (destroy), NULL);</pre>

<p>GTK+ emits the destroy signal when <code>gtk_widget_destroy()</code> is called on the widget or when <code>FALSE</code> is returned from a <code>delete_event()</code> callback function. The destroy signal belongs to the <code>GtkObject</code> class. This means that every class in GTK+ inherits the signal, and you can be notified of the destruction of any GTK+ structure.</p>

<p>There are four parameters to every g_signal_connect() call. The first is the widget that is to be monitored for the signal. Next, you specify the name of the signal you want to track. Each widget has many possible signals, all of which can be found in the API documentation. Remember that widgets are free to use the signals of their ancestors, since each widget is actually an implementation of each of its ancestors. You can use the “Object Hierarchy” section of the API to reference parent classes.</p>

<pre>gulong g_signal_connect (gpointer object,
const gchar *signal_name,
GCallback handler,
gpointer data);</pre>

<p>When typing the signal name, the underscore and dash characters are interchangeable. They will be parsed as the same character, so it does not make any difference which one you choose. I will use the underscore character for all of the examples in this book. The third parameter in g_signal_connect() is the callback function that will be called when the signal is emitted, cast with G_CALLBACK() . The format of the callback function depends on the function prototype requirements of each specific signal. An example callback function is shown in the next section.</p>

<h3>Button click</h3>

<p>When a button is fired, it sends a clicked signal. A button can be fired by a mouse pointer or with the Space key (provided the button has focus).</p>

<pre>
#include &lt;gtk/gtk.h&gt;

void button_clicked(GtkWidget *widget, gpointer data) {
    
  g_print("clicked\n");
}

int main(int argc, char *argv[]) {
    
  GtkWidget *window;
  GtkWidget *halign;
  GtkWidget *btn;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title(GTK_WINDOW(window), "GtkButton");
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_container_set_border_width(GTK_CONTAINER(window), 15);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);

  halign = gtk_alignment_new(0, 0, 0, 0);
  btn = gtk_button_new_with_label("Click");
  gtk_widget_set_size_request(btn, 70, 30);
  
  gtk_container_add(GTK_CONTAINER(halign), btn);
  gtk_container_add(GTK_CONTAINER(window), halign);

  g_signal_connect(G_OBJECT(btn), "clicked", 
      G_CALLBACK(button_clicked), NULL);

  g_signal_connect(G_OBJECT(window), "destroy", 
      G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>In the application, we have two signals: the clicked signal and the destroy signal.</p>

<pre>
g_signal_connect(G_OBJECT(btn), "clicked", 
    G_CALLBACK(button_clicked), NULL);
</pre>

<p>We use the g_signal_connect() function to connect the clicked signal to the button_clicked() callback.</p>

<pre>
void button_clicked(GtkWidget *widget, gpointer data) {
    
  g_print("clicked\n");
}
</pre>

<p>The callback prints the "clicked" string to the console. The first parameter of the callback function is the object which emitted the signal. In our case it is the Click button. The second parameter is optional. We may send some data to the callback. In our case, we did not send any data; we provided a NULL value to the fourth parameter of the g_signal_connect() function.</p>

<pre>
g_signal_connect(G_OBJECT(window), "destroy", 
     G_CALLBACK(gtk_main_quit), NULL);
</pre>

<p>If we press on the x button located in the upper right corner of the titlebar, or we press Atl+F4, a destroy signal is emitted. The gtk_main_quit() function is called, which terminates the application.</p>

<h2>Moving a window</h2>

<p>The next example shows how we react to window move events.</p>

<pre>
#include &lt;gtk/gtk.h&gt;

void configure_callback(GtkWindow *window, 
      GdkEvent *event, gpointer data) {
          
   int x, y;
   GString *buf;
   
   x = event->configure.x;
   y = event->configure.y;
   
   buf = g_string_new(NULL);   
   g_string_printf(buf, "%d, %d", x, y);
   
   gtk_window_set_title(window, buf->str);
   
   g_string_free(buf, TRUE);
}

int main(int argc, char *argv[]) {
    
  GtkWidget *window;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_widget_add_events(GTK_WIDGET(window), GDK_CONFIGURE);

  g_signal_connect(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), G_OBJECT(window));

  g_signal_connect(G_OBJECT(window), "configure-event",
        G_CALLBACK(configure_callback), NULL);

  gtk_widget_show(window);
  gtk_main();

  return 0;
}
</pre>

<p>In the example, we show the current position of the upper-left corner of our window in the titlebar.</p>

<pre>gtk_widget_add_events(GTK_WIDGET(window), GDK_CONFIGURE);</pre>

<p>The event mask of the widget determines what kind of events will a particular widget receive. Some event are preconfigured, other events have to be added to the event mask. The gtk_widget_add_events() adds a GDK_CONFIGURE event type to the mask. The GDK_CONFIGURE event type accounts for all size, position, and the stacking order of the window changes.</p>

<pre>g_signal_connect(G_OBJECT(window), "configure-event",
    G_CALLBACK(configure_callback), NULL);</pre>

<p>The configure-event is emitted when the size, position, or stacking of the widget's window has changed.</p>

<pre>
void configure_callback(GtkWindow *window, 
      GdkEvent *event, gpointer data) {
          
   int x, y;
   GString *buf;
   
   x = event->configure.x;
   y = event->configure.y;
   
   buf = g_string_new(NULL);   
   g_string_printf(buf, "%d, %d", x, y);
   
   gtk_window_set_title(window, buf->str);
   
   g_string_free(buf, TRUE);
}
</pre>

<p>The callback function has three parameters: the object that emitted the signal, the GdkEvent, and the optional data. We determine the x, y coordinates, build a string, and set it to the window title.</p>

<h2>The enter signal</h2>

<p>The following example shows how we can react to an enter signal. The enter signal is emitted when we enter the area of a widget with a mouse pointer.</p>

<pre>
#include &lt;gtk/gtk.h&gt;

void enter_button(GtkWidget *widget, gpointer data) {
     
  GdkColor col = {0, 27000, 30000, 35000};   
  
  gtk_widget_modify_bg(widget, GTK_STATE_PRELIGHT, &col);
}

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *halign;
  GtkWidget *btn;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_container_set_border_width(GTK_CONTAINER(window), 15);
  gtk_window_set_title(GTK_WINDOW(window), "Enter signal");

  halign = gtk_alignment_new(0, 0, 0, 0);

  btn = gtk_button_new_with_label("Button");
  gtk_widget_set_size_request(btn, 70, 30);
  
  gtk_container_add(GTK_CONTAINER(halign), btn);
  gtk_container_add(GTK_CONTAINER(window), halign);

  g_signal_connect(G_OBJECT(btn), "enter", 
      G_CALLBACK(enter_button), NULL);

  g_signal_connect(G_OBJECT(window), "destroy",
      G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>In the example, the background colour of the button widget is changes when we hover a mouse pointer over it.</p>

<pre>
g_signal_connect(G_OBJECT(btn), "enter", 
    G_CALLBACK(enter_button), NULL);
</pre>

<p>We call the enter_button() user function when the enter signal occurs.</p>

<pre>
void enter_button(GtkWidget *widget, gpointer data) {
     
  GdkColor col = {0, 27000, 30000, 35000};   
  
  gtk_widget_modify_bg(widget, GTK_STATE_PRELIGHT, &col);
}
</pre>

<p>Inside the callback, we change the background of the button by calling the gtk_widget_modify_bg() function.</p>

<h2>Disconnecting a callback</h2>

<p>We can disconnect a callback from the signal. The next code example demonstrates such a case.</p>

<pre>
#include &lt;gtk/gtk.h&gt;

gint handler_id;

void button_clicked(GtkWidget *widget, gpointer data) {
     
  g_print("clicked\n");
}

void toogle_signal(GtkWidget *widget, gpointer window) {
    
  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) {
     handler_id = g_signal_connect(G_OBJECT(window), "clicked", 
           G_CALLBACK(button_clicked), NULL);
  } else {
     g_signal_handler_disconnect(window, handler_id);
  }
}

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *hbox;
  GtkWidget *vbox;
  GtkWidget *btn;
  GtkWidget *cb;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
  gtk_container_set_border_width(GTK_CONTAINER(window), 15);
  gtk_window_set_title(GTK_WINDOW(window), "Disconnect");

  hbox = gtk_hbox_new(FALSE, 15);

  btn = gtk_button_new_with_label("Click");
  gtk_widget_set_size_request(btn, 70, 30);
  gtk_box_pack_start(GTK_BOX(hbox), btn, FALSE, FALSE, 0);

  cb = gtk_check_button_new_with_label("Connect");
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cb), TRUE);
  gtk_box_pack_start(GTK_BOX(hbox), cb, FALSE, FALSE, 0);
  
  vbox = gtk_vbox_new(FALSE, 5);
  gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);  

  handler_id = g_signal_connect(G_OBJECT(btn), "clicked", 
      G_CALLBACK(button_clicked), NULL);

  g_signal_connect(G_OBJECT(cb), "clicked",
      G_CALLBACK(toogle_signal), (gpointer) btn);

  g_signal_connect(G_OBJECT(window), "destroy",
      G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
</pre>

<p>In the code example, we have a button and a check box. The check box connects or disconnects a callback from the clicked signal of the button.</p>

<pre>
handler_id = g_signal_connect(G_OBJECT(btn), "clicked", 
    G_CALLBACK(button_clicked), NULL);

The g_signal_connect() returns the handler id which uniquely identifies the callback.

if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) {
   handler_id = g_signal_connect(G_OBJECT(window), "clicked", 
         G_CALLBACK(button_clicked), NULL);
} else {
   g_signal_handler_disconnect(window, handler_id);
}
</pre>

<p>This code determines the state of the check box. Depending on the state, it connects the callback with the g_signal_connect() function or disconnects with the g_signal_handler_disconnect() function.</p>

<h2>Drag and drop example</h2>

<p>In the next example, we show borderless window and learn how we can drag and move such a window.</p>

<pre>
#include &lt;gtk/gtk.h&gt;

gboolean on_button_press(GtkWidget* widget,
  GdkEventButton *event, GdkWindowEdge edge) {
      
  if (event->type == GDK_BUTTON_PRESS) {
      
    if (event->button == 1) {
      gtk_window_begin_move_drag(GTK_WINDOW(gtk_widget_get_toplevel(widget)),
          event->button,
          event->x_root,
          event->y_root,
          event->time);
    }
  }
  
  return TRUE;
}

int main(int argc, char *argv[]) {

  GtkWidget *window;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 250, 200);
  gtk_window_set_title(GTK_WINDOW(window), "Drag & drop");
  gtk_window_set_decorated(GTK_WINDOW(window), FALSE);
  gtk_widget_add_events(window, GDK_BUTTON_PRESS_MASK);

  g_signal_connect(G_OBJECT(window), "button-press-event",
      G_CALLBACK(on_button_press), NULL);

  g_signal_connect(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), G_OBJECT(window));

  gtk_widget_show(window);

  gtk_main();

  return 0;
}
</pre>

<p>The example demonstrates a drag and drop operation of a borderless window.</p>

<pre>gtk_window_set_decorated(GTK_WINDOW(window), FALSE);</pre>

<p>We remove the window decorations with the gtk_window_set_decorated() function. This means that the window will not have borders and titlebar.</p>

<pre>
g_signal_connect(G_OBJECT(window), "button-press-event",
    G_CALLBACK(on_button_press), NULL);
</pre>

<p>We connect the window to the button-press-event signal.</p>

<pre>
gboolean on_button_press(GtkWidget* widget,
  GdkEventButton *event, GdkWindowEdge edge) {
      
  if (event->type == GDK_BUTTON_PRESS) {
      
    if (event->button == 1) {
      gtk_window_begin_move_drag(GTK_WINDOW(gtk_widget_get_toplevel(widget)),
          event->button,
          event->x_root,
          event->y_root,
          event->time);
    }
  }
  
  return TRUE;
}
</pre>

<p>Inside the on_button_press() function, we perform the drag and drop operation. We check if the left mouse button was pressed. Then we call the gtk_window_begin_move_drag() function, which starts moving the window.</p>

<h2>A timer example</h2>

The following example demonstrates a timer example. Timers are used when we have some repeating tasks. It could be a clock, a count down, visual effects, or animations.</p>

<pre>
#include &lt;gtk/gtk.h&gt;

gchar buf[256];

gboolean on_expose_event(GtkWidget *widget,
    GdkEventExpose *event,
    gpointer data) {
        
  cairo_t *cr;

  cr = gdk_cairo_create(widget->window);

  cairo_move_to(cr, 30, 30);
  cairo_set_font_size(cr, 15);
  cairo_show_text(cr, buf);

  cairo_destroy(cr);

  return FALSE;
}

gboolean time_handler(GtkWidget *widget) {
    
  if (widget->window == NULL) return FALSE;

  GDateTime *now = g_date_time_new_now_local(); 
  gchar *my_time = g_date_time_format(now, "%H:%M:%S");
  
  g_sprintf(buf, "%s", my_time);
  
  g_free(my_time);
  g_date_time_unref(now);

  gtk_widget_queue_draw(widget);
  
  return TRUE;
}

int main(int argc, char *argv[]) {

  GtkWidget *window;
  GtkWidget *darea;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);

  darea = gtk_drawing_area_new();
  gtk_container_add(GTK_CONTAINER(window), darea);

  g_signal_connect(darea, "expose-event",
      G_CALLBACK(on_expose_event), NULL);
  g_signal_connect(window, "destroy",
      G_CALLBACK(gtk_main_quit), NULL);

  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);

  gtk_window_set_title(GTK_WINDOW(window), "Timer");
  g_timeout_add(1000, (GSourceFunc) time_handler, (gpointer) window);
  gtk_widget_show_all(window);
  time_handler(window);

  gtk_main();

  return 0;
}
</pre>

<p>The example displays the current local time on the window. The Cairo 2D library is also used.</p>

g_signal_connect(darea, "expose-event",
    G_CALLBACK(on_expose_event), NULL);

<p>We draw the time inside the on_expose_event() callback. The callback is connected to the expose-event signal, which is is emitted when the window is going to be redrawn.</p>

<pre>g_timeout_add(1000, (GSourceFunc) time_handler, (gpointer) window);</pre>

<p>This function registers the timer. The time_handler() function is called repeatedly at regular intervals; in our case in every second. The timer function is called until it returns FALSE.</p>

<pre>time_handler(window);</pre>

<p>This calls the timer function immediately. Otherwise, there would be one sec delay.</p>

<pre>
cairo_t *cr;

cr = gdk_cairo_create(widget->window);

cairo_move_to(cr, 30, 30);
cairo_set_font_size(cr, 15);
cairo_show_text(cr, buf);

cairo_destroy(cr);
</pre>

<p>This code draws the current time on the window. For more information about the Cairo 2D library, see the ZetCode's Cairo graphics tutorial.</p>

<pre>if (widget->window == NULL) return FALSE;</pre>

<p>When the window is destroyed, it may happen that the timer function is called. This line prevents working on an already destroyed widget.</p>

<pre>
GDateTime *now = g_date_time_new_now_local(); 
gchar *my_time = g_date_time_format(now, "%H:%M:%S");

g_sprintf(buf, "%s", my_time);
</pre>

<p>These lines determine the current local time. The time is stored in the global buf variable.</p>

<pre>gtk_widget_queue_draw(widget);</pre>

<p>The gtk_widget_queue_draw() function invalidates the window area, which then emits the expose-event signal.</p>

<section aria-label="End">
<a href="hello_world.html">&#171;Hello World</a>
<a href="../index.html">Index</a>
<a href="menus.html">Menus and toolbars &#187;</a>
</section>

</article>

</body>
</html>
