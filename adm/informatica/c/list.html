<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Linked lists"/>
    <title>Linked lists</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Documentation</a></li>
    </ul>
</nav>

<div class="content">

<h1>Linked lists</h1>

<p>Linked list are dynamic data structures, which can be used with a data collection that grows or shrinks during program execution.</p>

<p>Each element we will call it a <b>node</b> in a linked list is a combination of the data to be stored and a pointer to the next node. It is general practice to implement the node of a linked list as a self-referencing structure, i.e. a member of the structure will be a pointer to another instance of the same structure.</p>

<p>The basic operations that can be performed on a linked list are insert, delete and search. One disadvantage of using arrays to store data is that arrays are static structures and therefore cannot be easily extended or reduced to fit the data set. Arrays are also expensive to maintain new insertions and deletions.</p>

<p>The last node has a reference to NULL. The entry point into a linked list is called the <b>head</b> of the list. It should be noted that head is not a separate node, but the reference to the first node. If the list is empty then the head is a NULL reference.</p>

<p>A new element can be inserted at the beginning or at the end in constant time (in doubly linked lists). Memory utilization is efficient as it's allocated when we add new elements to a list and list size can increase/decrease as required. They are useful when the size of a list is unknown and changes frequently. It uses a node that stores data and a pointer to the next node.</p>

<p>The basic structure of a singly-linked list is:</p>

<pre>
head
 |
 v
---------     ---------     ---------
| a | --+---&gt; | b | --+---&gt; | c | NULL |
---------     ---------     ---------
</pre>

<p>Let's define a linked list node:</p>

<pre>
struct linked_list {
    int val;
    struct linked_list *next_ptr;
};

struct linked_list *first_ptr = NULL;
</pre>

<p>The variable first_ptr points to the first element of the list. In the beginning, before we insert any elements into the list (the list is empty), this variable is initialized to NULL.</p>

<h3>Example 1</h3>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct table {
	int points;
	int hand;
	struct table *next;
};

void init_struct (struct table *player);
void print_struct (struct table *player);

int main() {

	struct table player;
	
	player.next = malloc(sizeof(struct table));
	
	player.next->next = NULL;
	
	init_struct(&player);
	
	print_struct(&player);
	
	free(player.next);
	
	return 0;
}

void init_struct (struct table *player) {

		player->points = 5;
		player->hand = 30;	

		player->next->points = 10;
		player->next->hand = 77;
}

void print_struct (struct table *player) {

		printf("Dealer's data\n");
		
		printf("hand: %d\n", player->hand);
		printf("points: %d\n", player->points);
		
		printf("Player's data\n");
			
		printf("hand: %d\n", player->next->hand);
		printf("points: %d\n", player->next->points);
}
</pre>

<h3>Example 2</h3>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct linked_list {
        struct linked_list *next;       /* pointer to the next item */
        char data;
};

static void
add_item(struct linked_list **ptr, char data)
{
        struct linked_list *item;

        item = malloc(sizeof(*item));

        if (item == NULL)
                return;

        item->next = *ptr;
        item->data = data;
        *ptr = item;
}

void print_list(struct linked_list *current)
{
	if( current == NULL)
		printf("the list is empty\n");

	else
		printf("The list is:\n");

	while ( current != NULL) {
		printf("%d ---> ", current->data);
		current = current->next;
	}
	
	printf("NULL\n");
}

int
main(void)
{
        struct linked_list *head = NULL;

        add_item(&head, 1);
        add_item(&head, 2);
        add_item(&head, 3);

		print_list(head);

        /* here you have a list 3->2->1 */

        return (0);
}
</pre>

<h2>Print the list in reverse order</h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
   
/* Link list node */
struct Node
{ 
    int data;
    struct Node* next;
}; 
   
/* Function to reverse the linked list */
void printReverse(struct Node* head)
{ 
    // Base case
    if (head == NULL)
       return;
  
    /* print the list after head node */
    printReverse(head->next);
  
    /* After everything else is printed, print head */
    printf("%d  ", head->data);
} 
   
/* UTILITY FUNCTIONS */

/* Push a node to linked list. Note that this function
  changes the head */
void push(struct Node** head_ref, char new_data)
{ 
    /* allocate node */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));
   
    /* put in the data */
    new_node->data = new_data;
   
    /* link the old list off the new node */
    new_node->next = (*head_ref);
   
    /* move the head to pochar to the new node */
    (*head_ref) = new_node;
}  
   
/* Drier program to test above function */
int main() 
{
    // Let us create linked list 1->2->3->4
    struct Node* head = NULL;
    push(&head, 4);
    push(&head, 3);
    push(&head, 2);
    push(&head, 1);
    
    printReverse(head);
    return 0;
}
</pre>


<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
