<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Arrays"/>
	<title>Arrays</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>Arrays</h1>

<p>A one-dimensional array is a linear structure of a finite number of homogeneous elements, which are stored in consecutive locations in the memory. The elements in the array are referred by using an index or subscript. All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<h3>Declaring Arrays</h3>

<p>To declare an array in C, the type of the elements and their number is specified, e.g.</p>

<pre>int vector[5];</pre>

<h2>Initialization</h2>
    
<p>One-dimensional arrays can be readily initialized using a block type statement. In the following sequence, each element is initialized to an integer starting at one:</p>

<pre>int vector[5] = {10, 2, 13, 7, 5};</pre>
    
<p>or</p>

<pre>int vector [5] = {0}</pre>

<p>Assuming the integer size as 2 bytes, the array will be stored in memory as follows.</p>

<table class="noborder">
<tr><th>Memory address</th> <td>2000</td> <td>2001</td> <td>2002</td> <td>2003</td> <td>2004</td> </tr>

<tr><td></td> <td>10</td> <td>2</td> <td>13</td> <td>7</td> <td>5</td> </tr>

<tr><th>Index number</th> <td>0</td> <td>1</td> <td>2</td> <td>3</td> <td>4</td> </tr>
</table>

<p>The address of the first element of the array is also known as the base address of the array. When the name of an array is used in any expression, it is implicitly converted to a pointer to the first element of the array, (e.g. array name <i>vector</i> in an expression is equivalent to &vector[0]). The type of this pointer depends on the type of the array, if we have an array of <i>int</i> type then its type is 'constant pointer to int'. The two exceptions to this rule are when the array name is used as an operand of <i>sizeof</i> and & operators. When array name is operand of <i>sizeof</i> operator, the value returned is size of whole array and when array name is operand of & operators the value is a pointer to the whole array (not to the 1st element).</p>

<table class="noborder">
<tr><td>vector</td> <td>⟶</td> <td>Points to 1st element</td> <td>&vector[0]</td> <td>⟶</td> <td>10</td> </tr>

<tr><td>vector+1</td> <td>⟶</td> <td>Points to 2nd element</td> <td>&vector[1]</td> <td>⟶</td> <td>2</td> 

<tr><td>vector+2</td> <td>⟶</td> <td>Points to 3rd element</td> <td>&vector[2]</td> <td>⟶</td> <td>13</td> </tr>

<tr><td>vector+3</td> <td>⟶</td> <td>Points to 4th element</td> <td>&vector[3]</td> <td>⟶</td> <td>7</td> </tr>

<tr><td>vector+4</td> <td>⟶</td> <td>Points to 5th element</td> <td>&vector[4]</td> <td>⟶</td> <td>5</td> </tr>

</table>

<p>When the pointer is dereferenced, the indirection operator indicates that the value at that memory location stored in the pointer is to be accessed rather than the address itself, i.e. expression *<i>arr</i> and *(arr+0) represent the value of the first element of the array. In general we can write *(arr+i) ⟶ arr [i]. </p>

<table class="noborder">
<tr><td>*vector</td> <td>⟶</td> <td>Value of the 1st element</td> <td>vector[0]</td> <td>⟶</td> <td>2000</td> </tr>

<tr><td>*(vector+1)</td> <td>⟶</td> <td>Value of the 2nd element</td> <td>vector[1]</td> <td>⟶</td> <td>2001</td> 

<tr><td>*(vector+2)</td> <td>⟶</td> <td>Value of the 3rd element</td> <td>vector[2]</td> <td>⟶</td> <td>2002</td> </tr>

<tr><td>*(vector+3)</td> <td>⟶</td> <td>Value of the 4th element</td> <td>vector[3]</td> <td>⟶</td> <td>2003</td> </tr>

<tr><td>*(vector+4)</td> <td>⟶</td> <td>Value of the 5th element</td> <td>vector[4]</td> <td>⟶</td> <td>2004</td> </tr>

</table>

<p>Note that the array contents are actually stored in memory in binary form. For the above array, the total bytes needed are 2 ⋅ 5 = 10 bytes.</p>

<h2>Reading and Writing arrays</h2>

<p>In C, array can always be read or written through loop. We can get the address of an element of an array by applying the & operator in front os subscripted variable name, e.g. &arr[i] gives the address of the ith array element. To read a 1D array</p>

<pre>int num[5], i;
printf("Enter five elements:");
for(i=0; i &lt; n; i++)
	scanf("%d", &vector[i]); /*read and place the values in the array */</pre>

<p>For displaying the content of an array and their address</p>

<pre>printf("Elements address:");
for(i=0; i &lt; n; i++)
	pritnf("%d %u", vector[i], &vector[i]);</pre>

<p>In C language, pointers and arrays are closely related. We can access the array elements using pointer expressions. Actually the compiler accesses the array elements by converting subscript notation to pointer notation. As said the name of the array is a constant pointer to its first element and according to pointer arithmentic, when an integer is added to a pointer then we get the address of the next element; Hence <i>vector</i>+1 denotes the address of the next element, i.e. <i>vector</i>[1]: Similarly <i>vector</i>+2 denotes the address of <i>vector</i>[2] and so on.</p>



<h3 id="memset">Memset</h3>

<p>The internal representation of an array has no information about the number of elements it contains. The array name simply references a block of memory. Using the <a href="sizeof.html">sizeof operator</a> with an array will return the number of bytes allocated to the array. To determine the number of elements, we divide the array’s size by its element’s size, as illustrated below. This will display 5:</p>

<pre>printf("%d\n", sizeof(vector)/sizeof(int));</pre>

<p>Then if you want to restore the values to zero use <b>memset</b> defined in &lt;string.h&gt;. <code>memset()</code> is used to fill a block of memory with a particular value. Its declaration</p>

<pre>void *memset(void *str, int c, size_t n)</pre>

<p><b>Note</b>: When you declare an array, you say vector[4] to specify it contains four cells but after that, the number in [ ] is used to specify which cell you're referring to, not the number of cells. So when you say <code>vector[4] = 0</code> you're asking the computer to set cell number 4 to 0. You cannot initialized inside a structure declaration, you have to use <code>memset</code>.</p>

<h3>Parameters</h3>

<ul>
    <li><p>str − This is a pointer to the block of memory to fill.</p></li>

    <li><p>c − This is the value to be set. The value is passed as an int, but the function fills the block of memory using the unsigned char conversion of this value.</p></li>

    <li><p>n − This is the number of bytes to be set to the value.</p></li>
</ul>

<h3>Example</h3>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
  
int main() 
{ 
    char str[50] = "Giovanni is a programming geeks."; 
    printf("\nBefore memset(): %s\n", str); 
  
    // Fill 8 characters starting from str[13] with '.' 
    memset(str + 13, '.', 8*sizeof(char)); 
  
    printf("After memset():  %s", str); 
    return 0; 
}
</pre>

<p>produce l'output</p>

<pre>
Before memset(): Giovanni is a programmer geek.
After memset():  Giovanni is a........mer geek.
</pre>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="arrays_of_strings.html">Arrays of strings &#187;</a>
</section>

</article>

</body>
</html>
