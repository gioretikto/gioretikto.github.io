<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="Stacks in function Calls"/>
    <title>Stacks in function Calls</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.php">Home</a></li>
        <li><a class="navbar" href="../../documentation.html">Documentation</a></li>
    </ul>
</nav>
      
<div class="content">

<h1>Stacks in function Calls</h1>

<p>A stack is a data structure where items can be inserted and deleted with certain constraints. The constraints applicable to stacks are enumerated here:</p>

<ul>
	<li><p>A stackis a LIFO ("last in, first out" list of items) where the last item inserted (conventionally at the top of the stack) is the first item removed when requested. </p></li>
	<li><p>An insertion (or a push operation in the stack nomenclature) inserts the item at the top.</p></li>
	<li><p>A deletion (or a pop operation in the stack nomenclature) removes the item from the top.</p></li>
</ul>

<p>Thus, a stack can be conceptualized as a pipe with one end closed and another (the top end) open. Any push or pop has to be carried out through the single open end and, hence, it acts as a LIFO data structure. As we know, the code for our program is loaded in memory from storage before execution. Since memory units have addresses, the program is said to be loaded in memory at a specific address. Thus, each compiled instruction is placed at a particular address in memory. When a function call is encountered, the CPU switches execution to the starting address of the invoked function. However, as we have seen, control is switched back to the caller when the invoked function returns. This return is at the exact point where it left off in the caller. It would be very difficult to keep track of the return address and the states of the local variables in the caller, had it not been for stacks. When a program is in execution, it is allocated a stack (also called the <b>activation stack</b>) for the purpose of storing local variables and keeping track of function calls by storing the return address of the calling function, along with some miscellaneous information like argument count, etc. Together, they constitute the state of a function at a given instant of time. Such information is also termed as an activation record. Each function call creates a new activation record on the stack. When a program is in execution, the activation record of the currently executing function is present on the top of the activation stack. Thus, at any instant of time, the record at the top of the stack contains the return address (specifying the next instruction to be executed) of the caller of the present function and the current local variables for the function. When a function call is encountered, the actual parameters for the function call are evaluated. A new activation record is created on the activation stack. The storage (memory) for the formal parameters and local variables of the called function are allocated on the newly created activation record, now on top of the stack.</p>

<p>Then, the return address field for the newly created activation record is initialized with the address of the next statement to be executed in the invoked function. The CPU begins execution from the starting address of the called function.</p>

<p>After the invoked function completes its assigned task and returns, the return value (if any) together with the return address of the caller, as stored in the activation record for the completed function, is stored in a temporary section in memory. Then the activation record of the completed function is popped from the activation stack, so that the top of the activation stack now contains the activation record of the caller. The activation record on top is then modified by allocating the return value as stored in the temporary section into the appropriate local variable of the function in its activation stack. The CPU then begins execution with the return address in the temporary section, which gives the location where execution left off in the caller.</p>

<p>The technique is true for any number of function calls to any depth of call - viz. a() → b() → c() → d()... -as long as the activation stack permits enough space for the storage of activation records of the functions.</p>

<p>The states of the activation stack for successive calls are shown in Figure 1, where the function names indicate the activation records for the corresponding functions.</p>

<figure>
<img src="img/stack_img.png" alt="Activation stack content"/>
<figcaption><b>Fig 1</b> - The Activation Stack Contents (Step by step) fot the Function-Calling Sequence a() → b() → c() → d()</figcaption>
</figure>

<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
