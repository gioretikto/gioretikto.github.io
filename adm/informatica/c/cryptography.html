<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="Cryptography"/>
    <title>Cryptography</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Index</a></li>
    </ul>
</nav>
      
<div class="content">

<h1>Cryptography</h1>

<p><i>Symmetric key cryptography</i>, also called shared key cryptography, involves two people using the same key to encrypt and decrypt information. <i>Public key cryptography</i> makes use of two different keys: a public key for encryption and a private key for decryption. Symmetric key cryptography has the advantage that it’s much faster than public key cryptography. It is also generally easier to implement and usually requires less processing power. On the downside, the two parties sending messages must agree on the same private key before securely transmitting information. This is often inconvenient or even impossible. If the two parties are geographically separated, then a secure means of communication is needed for one to tell the other what the key will be. In a pure symmetric key scenario, secure communication is generally not available. (If it were, there would be little need for encryption to create another secure channel.) Public key cryptography has the advantage that the public key, used for encryption, does not need to be kept secret for encrypted messages to remain secure. This means public keys can be transmitted over insecure channels. Often, applications use public key cryptography to establish a shared session key and then communicate via symmetric key cryptography using the shared session key. This solution provides the convenience of public key cryptography with the performance of shared key cryptography. Both public key and symmetric key cryptography are used to get secure information from the web. First your browser establishes a shared session key with the website using public key cryptography. Then you comunicate with the website using symmetric key cryptography to actually obtain the private information.</p>

<h2>Hashing</h2>

<p>A cryptographic hash algorithm is a one-way function that takes a variable-length input and produces a fixed-size output called a digest, hash, or fingerprint. At the most basic level, <i>hashing functions</i> are functions that take very large data as their input and generate very small data as their
output. In cryptography, we define hash functions as a function that takes a variable sized long input of bits and produces a fixed, small sequence of bits that is effectively unique. Of course, it cannot be completely unique but given a set of expected inputs, the probability that two outputs are the same,
also called the collision probability, should be small. In addition, good cryptographic hash functions must be one-way. That is, it must be easy to compute the hash value but difficult to use the hash value to predict the input.</p>

<p>An example of hashing in linux</p>

<pre>echo -n "let's get started" | md5sum</pre>

<p>The MD5 function however is no longer considered secure; its algorithm can now be broken by commonly abailable computers. SHA-256 is currently a more acceptable standard.</p>

<h3>Hashing is in one direction</h3>

<blockquote>Hashing differs significantly from encryption, however, in that it is a one-way process.</blockquote>

<p>There is <b>no easy way to unscramble the data</b>, interpret the output, or reverse-engineer the input. There’s no key, no system of two keys, no publicly-accessible keys, no certificates that will grant you access to the original data. At risk of over-extending the metaphor, once you bake the data into the hash, there’s no unbaking it.</p>

<h4>A is a great tool for storing authentication information like passwords.</h4>

<p>When a user creates a password on a site with strong security, it passes through a hashing algorithm and gets stored on the site’s data cache in its nonsensical, standardized hash format. The next time you log in, the system will create a new hash of the password you enter and compare it to the one they made from the original. If a cybercriminal hacks the data, all (s)he has is a bundle of hashed passwords that can’t be used as login credentials because there is no key to unlock the data in its original form.</p>

<p>Hashes come in different flavors (no pun intended). Cybersecurity teams that want to hash passwords for storage have numerous hashing algorithms to choose from, including:</p>

<ul>
	<li><p><b>MD5</b>. The MD5 algorithm encodes a string of information into a 128-bit fingerprint. It’s one of the oldest and most widely-used hashing algorithms in the world, but it is also starting to show its age in the form of a high risk of hash collision.</p></li>

    <li><p><b>SHA-2</b>. Developed by the NSA, this cryptographic hash function builds on the older SHA-1 algorithm. Both the current algorithm and its predecessor use six hashing algorithms in 244-, 256-, 384-, or 512-bit configurations.</p></li>

    <li><p><b>CRC32.</b> “CRC” stands for “cyclical reduction check.” It’s a kind of code used to discover errors or changes in a data set. Mostly used in zip files or for file integrity checks, CRC32 produces the same hashed output every time it is run.</p></li>

    <li><p><b>RipeMD.</b> Available in multiple bit configurations with 160-bit the most popular, RipeMD is a cryptographic hashing algorithm that is used in the Bitcoin standard. Other cryptocurrencies use it as well.</p></li>

    <li><p><b>Tiger.</b> Tiger is a hash function invented to work with 64-bit platforms. Available in 128-bit and 160-bit configurations, Tiger has no distinguishing initializing values. It appends a byte with hexadecimal value 0x01. A variation, Tiger2, appends a byte with hexadecimal value 0x08.</p></li>

    <li><p><b>xxHash.</b> xxHash is a non-cryptographic hash function known for its exceptional speed, working at RAM speed limits. The most up-to-date variation, XXH3, performs exceptionally well with small data.</p></li>

    <li><p><b>BCrypt.</b> This hash function is designed to be slow, with the intention of making password cracking more time consuming and discouraging cybercriminals attempting to execute quick attacks.</p></li>
    
    <li><p><b>Argon2.</b> Argon2 uses an “adaptive” hashing algorithm that can be calibrated with a “work factor,” making the hash more or less complicated.</p></li>
</ul>

<p>Hash functions have several different properties that make them useful:</p>

<ul>
    <li><p><b>They are one-way functions</b> – This means that there is no practical way to figure out what the original input was from a given hash value.
    <li><p><b>It’s unlikely for two inputs to have the same hash value</b> – While it is possible for two different inputs to yield the same hash value, the chances of this happening are so small that we don’t really worry about it. For practical purposes, hash values can be considered unique.</p></li>
    <li><p><b>The same input always delivers the same result</b> – Every time you put the same information into a given hash function, it will always deliver the same output.</p></li>
    <li><p><b>Even the slightest change gives a completely different result</b> – If even a single character is altered, the hash value will be vastly different.</p></li>
</ul>

<h3>Hash collision</h3>

<p>Hash algorithms are not perfect. One vulnerability to guard against is hash collision. Any scrambling algorithm carries with it the risk of collision, which is the production of the same scrambled output from two different inputs. It is also known as a clash. This is a vulnerability attackers can potentially exploit, because they only need to know part of a password (or a common part of a password) to enter it into a hash function and discover a common hashed output, gaining a foot in the door even without the entire correct password.</p>

<h2>Salting</h2>

<p>Salting is essentially the addition of random data before it is put through a hash function, and they are most commonly used with passwords.</p>

<p>The best way to explain using salts is to discuss why we need them in the first place. You might have thought that storing the hashes of passwords would have solved all of our problems, but unfortunately, things are a little more complex than that.</p>

<h4>Weak passwords</h4>

<p>A lot of people have really bad passwords, maybe you do too. The problem is that humans tend to think in predictable patterns and choose passwords that are easy to remember. These passwords are vulnerable to dictionary attacks, which cycle through thousands or millions of the most common password combinations each second, in an attempt to find the correct password for an account.</p>

<p>If password hashes are stored instead, things are a little bit different. When an attacker comes across a database of password hashes, they can use either hash tables or rainbow tables to look up matching hashes which they can use to find out the passwords.</p>

<p>A hash table is a pre-computed list of hashes for common passwords that is stored on a database. They require more work ahead of time, but once the table has been completed, it is much faster to look up the hashes in the table than it is to compute the hash for each possible password. Another advantage is that these tables can be used repeatedly.</p>

<p>Rainbow tables are similar to hash tables, except they take up less space at the cost of more computing power.</p>

<p>Both of these attack methods become far more practical if weak passwords are used. If a user has a common password, then it is likely that the hash for the password will be in the hash table or rainbow table. If this is the case, then it’s only a matter of time before an attacker has access to a user’s password.</p>

<p>Users can help to foil these attacks by choosing longer and more complex passwords that are far less likely to be stored in the tables. In practice, this doesn’t happen anywhere near as much as it should, because users tend to choose passwords that are easy to remember. As a loose rule of thumb, things that are easy to remember are often easy for attackers to find.</p>

<p>Salts offer another way of getting around this issue. By adding a random string of data to a password before it is hashed, it essentially makes it more complex, which hampers the chances of these attacks succeeding. How salting works in practice</p>

<p>As an example, let’s say you have an email account and your password is “1234”. When we use an SHA-256, we get the following as the hash value:</p>

<pre>echo -n "1234" | sha256sum
03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4
</pre>

<p>This hash is what would be stored in the database for your account. When you enter your password of “1234”, it is hashed and then the value is compared against the stored value. Since the two values are the same, you will be granted access.</p>

<p>If an attacker breaks into the database, they will have access to this value, as well as all of the other password hashes that were there. The attacker would then take this hash value and look it up in their pre-computed hash table or rainbow table. Since “1234” is one of the most common passwords, they would find the matching hash very quickly.</p>

<p>The hash table would tell them that:</p>

<pre>03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4</pre>

<p>Corresponds to: 1234</p>

<p>The attacker will then know that your password is “1234”. The attacker can then run an automated script to compare the two lists—the stolen hashed passwords and the hashed list of common passwords. The latter is known as a rainbow list or rainbow table. If the script reveals a match between the two lists, the attacker has found a working password. They can then use this password to log in to your account.</p>

<p>As you can see, this wasn’t a whole lot of work for the attacker. To make things more difficult, we add a salt of random data to the password before it is hashed. Salting helps to significantly reduce the chances of hash tables and rainbow tables from returning a positive result.</p>

<p>Let’s take a 16 character salt of random data:</p>

<pre>H82BV63KG9SBD93B</pre>

<p>We add it to our simple password of “1234” like so:</p>

<pre>1234H82BV63KG9SBD93B</pre>

<p>Only now that we have salted it do we put it through the same hash function that we did before, which returns:</p>

<pre>91147f7666dc80ab5902bde8b426aecdb1cbebf8603a58d79182b750c10f1303</pre>

<p>Sure, this hash value isn’t any longer or more complex than the previous one, but that’s not the point. While they are both the same length, “1234H82BV63KG9SBD93B” is a far less common password, so it’s much less likely that its hash will be stored in the hash table.</p>

<p>The less likely a password is to be stored in a hash table, the less likely for an attack to succeed. This is how adding salts helps to make password hashes more secure.</p>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
