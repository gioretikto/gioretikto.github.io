<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="sizeof operator"/>
	<title>sizeof operator</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>Pointers</h1>

<p>Pointers are a very useful part of efficient C programming. They are variables that store the memory address of other variables.</p>

<p>When a regular variable is declared, memory is allocated, of the size appropriate for its data type, at a vacant memory address. Subsequently, wherever the program finds that variable name it references the data stored at that memroy address. Similarly, wherever the program finds the name of a pointer variable it references the adress it stores. But a pointer variable can be "dereferences" to reveal the data stored at the address it contains.</p>

<blockquote>A pointer variable name, when used alone, references a memory address expressed in hexadecimal</blockquote>

<p>Pointer variables are declared in just the same way that other variables are declared but the variable name is prefixed by a *</p>

<pre>int *p; /* puntatore ad intero */</pre>

<p>or alternatevely</p>

<pre>int* p;</pre>

<p>The pointer's data type must match the data type of the variable to which it points.</p>

<p id="ref">Simply declaring a pointer (just requesting storage to hold an address), does not make it point to anything. To use a pointer, we must initialize it to the address of an actual object using the <b>reference (address) operator</b> & before the identifier of the object.</p>

<p>Once declared, a pointer variable can be assigned the  &amp;</p>

<pre>p = &c;</pre>

<p>assigns the address of <code>c</code> to the pointer <code>p</code>, and <code>p</code> is said to "point to" <code>a</code>. The &amp; operator only applies to objects in memory: variables and array elements. It cannot be applied to expressions, constants, or register variables. L'<b>dereference operator</b> *, has two tasks</p>

<ul>
	<li><p>Declaration of a pointer</p></li>
	<li><p>Restituisce il valore dell'oggetto puntato dal suo operando</p></li>
</ul>

<blockquote>A pointer variable name, when prefixed by the * dereference operator after its declaration, references the data stored at the address assigned to that pointer variable</blockquote>

<p>The following example makes use of these operations</p>

<pre>
#include &lt;stdio.h&gt;

int main () {

   int  var = 20;   /* actual variable declaration */
   int  *ip;        /* pointer variable declaration */

   ip = &amp;var;  /* store address of var in pointer variable*/

   printf("Address of var variable: %p\n", &amp;var);

   /* address stored in pointer variable */
   printf("Address stored in ip variable: %p\n", ip);

   /* access the value using the pointer */
   printf("Value of *ip variable: %d\n", *ip );

   printf("Address of ip variable: %p\n", &ip);

   return 0;
}
</pre>

<p>When the above code is compiled and executed, it produces the following result −</p>

<pre>
Address of var variable: bffd8b3c
Address stored in ip variable: bffd8b3c
Value of *ip variable: 20
</pre>

<p>La specifica di conversione %p della printf invierà in output la locazione di memoria, convertendola in un intero esadecimale.</p>

<pre>
/* Esempio utilizzo operatore &amp; */
#include &lt;stdio.h&gt;

int main ()
{
  int  var1;
  char var2[10];

  printf("Address of var1 variable: %x<kbd>\n</kbd></cite>", &amp;var1);
  printf("Address of var2 variable: %x<kbd>\n</kbd></cite>", &amp;var2);
   
  return 0;
}</pre>

<p>output</p>

<pre>
Address of var1 variable: aff5a300
Address of var2 variable: afd5a3f8
</pre>

<p><b>Note</b> Memory address is always a positive value. So we can use  format string character <code>%u</code> for printing the address.</p>

<h3>NULL Pointers</h3>

<p>It is always a good practice to assign a NULL value to a pointer variable in case you do not have an exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NULL is called a null pointer.</p>

<p>The NULL pointer is a constant with a value of zero defined in several standard libraries. Consider the following program −</p>

<pre>
#include &lt;stdio.h&gt;

int main () {

   int *ptr = NULL;

   printf("The value of ptr is : %x\n", ptr);
 
   return 0;
}
</pre>

<p>When the above code is compiled and executed, it produces the following result −</p>

<pre>The value of ptr is 0</pre>

<p>In most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the null (zero) value, it is assumed to point to nothing.</p>

<p>To check for a null pointer, you can use an 'if' statement as follows −</p>

<pre>
if(ptr)     /* succeeds if p is not null */
if(!ptr)    /* succeeds if p is null */
</pre>

<h2>Puntatori ad array</h2>

<pre>
#include &lt;stdio.h&gt;

int main(){
    int a[2]={3,4};
    int *pa;
    pa = a;
    pa[1]++;
    printf("%d\n",a[1]);
    return 0;
}
</pre>

<p>output</p>

<pre>5</pre>

<h3>Example 2</h3>

<pre>
#include &lt;stdio.h&gt;

int main(){
    
    char a[]={'a','e','i','o','u'};
    int i;
    char *pt = &a[0];
      
      for(i=0; i &lt; 5; i++){
        printf("%c\n", *pt);
        printf("%p\n", pt);
        pt++;
    }
    
    return 0;
}
</pre>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="stringhe.html">Puntatore a caratteri: stringhe &#187;</a>
</section>

</article>

</body>
</html>
