<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Makefile">
	<title>Makefile</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>Makefile</h1>

<p>When an application is made up of more tha a few source files, compiling and linking the files by manually typing the <code>gcc</code> command can get tiresome. Also, you don't wanto to compile every file whenever you change something is a single source file. The situations are where the GNU <code>make</code> utility comes to your rescue. The make utility works by reading and interpreting a <code>makefile</code> - a text file that describes which files are required to build a particular program, as well as how to compile and link the files to build the program. Wheneever you change on or more files, <code>make</code> determines which files to recompile, and it issues the appropriate commands for compiling those files are rebuilding the program.</p>

<p>By default, GNU make looks for a makefile that has one of the following names, in the order shown:</p>

<ul>
	<li><p>GNUmakefile</p></li>
	<li><p>makefile</p></li>
	<li><p>Makefile</p></li>
</ul>

<p>In Unix system, using <code>Makefile</code> as the name of the makefile is customary because it appears near the beginning of directory listings, whilce uppercare names appear before lowercase names. If you makefile is called <code>myprogram.mak</code>, for example, you have to run make using the following command line:</p>

<pre>make -f myprogram.mak</pre>

<p>Suppose that you have a c source file named form.c that containg the preprocessor directive <code>#include "form.h"</code>. The object <code>form.o</code> clearly depende on the source file <code>form.c</code> and the header file form.h. In additoin to these dependencies, you must specify how make converts the <code>form.c</code> file to the object file form.o. Supposue that you want make to invoke gcc with these option:</p>

<ul>
	<li><p>c (compile only)</p></li>
	<li><p>g (generate debugging information)</p></li>
	<li><p>O2 (optimize some)</p></li>
</ul>

<pre>
# This is a comment in the makefile
# the following lines indicate how form.o depends
# on form.c and form.h and how to create form.o
form.o: form.c form.h
	g++ -c -g -O2 form.c
</pre> 

<p>You can have a rule such as this one:</p>

<pre>
clean:
	rm -f *.o
</pre>

<p>This rules specifies an abstract target named <code>clean</code> that doesn't depend on anything. This dependency statement says that ot create target <code>clean</code>, GNU make invokes the command <code>rm -f *.o</code>, which deletes all ifles that have the .o extension (namely, the object files). Thus, the effect of creating the target named <code>clean</code> is to delete the object files.</p>

<p>The first line uses ":" to indicate dependence - form.o depends on foo.c. If foo.o does not exist or foo.c in newer than foo.c, then the command in the next line will be executed. A <b>Tab key</b> is needed before gcc at the second time. In make Tab cannot be replaced by spaces</p>

<h2>Variables (or macros)</h2>

<p>In addition to the basic capability of building targets from dependents, GNU make includes many features that make it easy for you to express the dependencies and rules for building a target from its dependents. If you need to compile a large number of C++ files by using GCC with the same options, for example, typing the options for each file is tedious. You can avoid this repetitive task by defining a variable or macro in make as follows:</p>

<pre>
# Define macros for name of compiler
CXX= g++

# Define a macro for the GCC flags
CXXFLAGS= -02 -g -mcpu=i686

# A rule for building an object file
form.o: form.C form.h
	$(CXX) -c $(CXXFLAGS) form.C
</pre>

<p>In this example, CXX and CXXFLAGS are make variables. (GNU make prefers to call them variables, but most Unix make utilities call them macros.)</p>

<p>To use a variable anywhere in the makefile, start with a dollar sign ($) followed by the variable within parentheses. GNU make replaces all occurrences of a vari- able with its definition; thus, it replaces all occurrences of $(CXXFLAGS) with the string -O2 -g -mcpu=i686.</p>

<p>GNU make has several predefined variables that have special meanings. Table 3-2 lists these variables. In addition to the variables listed in Table 3-2, GNU make considers all environment variables (such as PATH and HOME) to be predefined variables as well.</p>

<h2>Setting Variables</h2>

<p>To set a variable from the makefile, write a line starting with the variable name followed by ‘=’, ‘:=’, or ‘::=’. Whatever follows the ‘=’, ‘:=’, or ‘::=’ on the line becomes the value. For example,</p>

<pre>objects = main.o foo.o bar.o utils.o</pre>

<p>defines a variable named objects. Whitespace around the variable name and immediately after the ‘=’ is ignored.</p>

<p>Variables defined with ‘=’ are recursively expanded variables. Variables defined with ‘:=’ or ‘::=’ are simply expanded variables; these definitions can contain variable references which will be expanded before the definition is made. See The Two Flavors of Variables.</p>

<p>The variable name may contain function and variable references, which are expanded when the line is read to find the actual variable name to use.</p>

<p>There is no limit on the length of the value of a variable except the amount of memory on the computer. You can split the value of a variable into multiple physical lines for readability (see Splitting Long Lines).</p>

<p>Most variable names are considered to have the empty string as a value if you have never set them. Several variables have built-in initial values that are not empty, but you can set them in the usual ways (see Variables Used by Implicit Rules). Several special variables are set automatically to a new value for each rule; these are called the automatic variables (see Automatic Variables).</p>

<p>If you’d like a variable to be set to a value only if it’s not already set, then you can use the shorthand operator ‘?=’ instead of ‘=’. These two settings of the variable ‘FOO’ are identical (see The origin Function):</p>

<pre>FOO ?= bar</pre>

<p>and</p>

<pre>
ifeq ($(origin FOO), undefined)
FOO = bar
endif
</pre>

<p>The shell assignment operator ‘!=’ can be used to execute a shell script and set a variable to its output. This operator first evaluates the right-hand side, then passes that result to the shell for execution. If the result of the execution ends in a newline, that one newline is removed; all other newlines are replaced by spaces. The resulting string is then placed into the named recursively-expanded variable. For example:</p>

<pre>hash != printf '\043'
file_list != find . -name '*.c'</pre>

<p>If the result of the execution could produce a $, and you don’t intend what follows that to be interpreted as a make variable or function reference, then you must replace every $ with $$ as part of the execution. Alternatively, you can set a simply expanded variable to the result of running a program using the shell function call. See The shell Function. For example:</p>

<pre>
hash := $(shell printf '\043')
var := $(shell find . -name "*.c")
</pre>

<p>As with the shell function, the exit status of the just-invoked shell script is stored in the .SHELLSTATUS variable. </p>

<h2>Automatic Variables</h2>

<p>Suppose you are writing a pattern rule to compile a ‘<samp>.c</samp>’ file into a ‘<samp>.o</samp>’ file: how do you write the ‘<samp>cc</samp>’ command so that it operates on the right source file name?  You cannot write the name in the recipe, because the name is different each time the implicit rule is applied.</p>

<p>What you do is use a special feature of <code>make</code>, the <em>automatic variables</em>.  These variables have values computed afresh for each rule that is executed, based on the target and prerequisites of the rule.  In this example, you would use ‘<samp>$@</samp>’ for the object file name and ‘<samp>$&lt;</samp>’ for the source file name.</p>

<span id="index-prerequisites_002c-and-automatic-variables"></span> <p>It’s very important that you recognize the limited scope in which automatic variable values are available: they only have values within the recipe.  In particular, you cannot use them anywhere within the target list of a rule; they have no value there and will expand to the empty string.  Also, they cannot be accessed directly within the prerequisite list of a rule.  A common mistake is attempting to use <code>$@</code> within the prerequisites list; this will not work.  However, there is a special feature of GNU <code>make</code>, secondary expansion (see Secondary Expansion), which will allow automatic variable values to be used in prerequisite lists.</p>

<p>Here is a table of automatic variables:</p>

<dl compact="compact">
<dd><span id="index-_0024_0040"></span>
<span id="index-_0040-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$@</code></dt>
<dd><p>The file name of the target of the rule.  If the target is an archive
member, then ‘<samp>$@</samp>’ is the name of the archive file.  In a pattern
rule that has multiple targets (see <a href="Pattern-Intro.html#Pattern-Intro">Introduction to
Pattern Rules</a>), ‘<samp>$@</samp>’ is the name of whichever target caused the
rule’s recipe to be run.
</p>
<span id="index-_0024_0025"></span>
<span id="index-_0025-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$%</code></dt>
<dd><p>The target member name, when the target is an archive member.
See <a href="Archives.html#Archives">Archives</a>.  For example, if the target is <samp>foo.a(bar.o)</samp> then
‘<samp>$%</samp>’ is <samp>bar.o</samp> and ‘<samp>$@</samp>’ is <samp>foo.a</samp>.  ‘<samp>$%</samp>’ is
empty when the target is not an archive member.
</p>
<span id="index-_0024_003c"></span>
<span id="index-_003c-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$&lt;</code></dt>
<dd><p>The name of the first prerequisite.  If the target got its recipe from
an implicit rule, this will be the first prerequisite added by the
implicit rule (see <a href="Implicit-Rules.html#Implicit-Rules">Implicit Rules</a>).
</p>
<span id="index-_0024_003f"></span>
<span id="index-_003f-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$?</code></dt>
<dd><p>The names of all the prerequisites that are newer than the target, with
spaces between them.  If the target does not exist, all prerequisites
will be included.  For prerequisites which are archive members, only the
named member is used (see <a href="Archives.html#Archives">Archives</a>).
<span id="index-prerequisites_002c-list-of-changed"></span>
<span id="index-list-of-changed-prerequisites"></span>
</p>
<span id="index-_0024_005e"></span>
<span id="index-_005e-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$^</code></dt>
<dd><p>The names of all the prerequisites, with spaces between them.  For
prerequisites which are archive members, only the named member is used
(see <a href="Archives.html#Archives">Archives</a>).  A target has only one prerequisite on each other file
it depends on, no matter how many times each file is listed as a
prerequisite.  So if you list a prerequisite more than once for a target,
the value of <code>$^</code> contains just one copy of the name.  This list
does <strong>not</strong> contain any of the order-only prerequisites; for those
see the ‘<samp>$|</samp>’ variable, below.
<span id="index-prerequisites_002c-list-of-all"></span>
<span id="index-list-of-all-prerequisites"></span>
</p>
<span id="index-_0024_002b"></span>
<span id="index-_002b-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$+</code></dt>
<dd><p>This is like ‘<samp>$^</samp>’, but prerequisites listed more than once are
duplicated in the order they were listed in the makefile.  This is
primarily useful for use in linking commands where it is meaningful to
repeat library file names in a particular order.
</p>
<span id="index-_0024_007c"></span>
<span id="index-_007c-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$|</code></dt>
<dd><p>The names of all the order-only prerequisites, with spaces between
them.
</p>
<span id="index-_0024_002a"></span>
<span id="index-_002a-_0028automatic-variable_0029"></span>
</dd>
<dt><code>$*</code></dt>
<dd><p>The stem with which an implicit rule matches (see <a href="Pattern-Match.html#Pattern-Match">How
Patterns Match</a>).  If the target is <samp>dir/a.foo.b</samp> and the target
pattern is <samp>a.%.b</samp> then the stem is <samp>dir/foo</samp>.  The stem is
useful for constructing names of related files.
<span id="index-stem_002c-variable-for"></span>
</p>
<p>In a static pattern rule, the stem is part of the file name that matched
the ‘<samp>%</samp>’ in the target pattern.
</p>
<p>In an explicit rule, there is no stem; so ‘<samp>$*</samp>’ cannot be determined
in that way.  Instead, if the target name ends with a recognized suffix
(see <a href="Suffix-Rules.html#Suffix-Rules">Old-Fashioned Suffix Rules</a>), ‘<samp>$*</samp>’ is set to
the target name minus the suffix.  For example, if the target name is
‘<samp>foo.c</samp>’, then ‘<samp>$*</samp>’ is set to ‘<samp>foo</samp>’, since ‘<samp>.c</samp>’ is a
suffix.  GNU <code>make</code> does this bizarre thing only for compatibility
with other implementations of <code>make</code>.  You should generally avoid
using ‘<samp>$*</samp>’ except in implicit rules or static pattern rules.
</p>
<p>If the target name in an explicit rule does not end with a recognized
suffix, ‘<samp>$*</samp>’ is set to the empty string for that rule.
</p></dd>
</dl>

<p>‘<samp>$?</samp>’ is useful even in explicit rules when you wish to operate on only
the prerequisites that have changed.  For example, suppose that an archive
named <samp>lib</samp> is supposed to contain copies of several object files.
This rule copies just the changed object files into the archive:
</p>
<div class="example">
<pre class="example">lib: foo.o bar.o lose.o win.o
        ar r lib $?
</pre></div>

<p>Of the variables listed above, four have values that are single file names, and three have values that are lists of file names.  These
seven have variants that get just the file’s directory name or just the file name within the directory.  The variant variables’ names are
formed by appending ‘<samp>D</samp>’ or ‘<samp>F</samp>’, respectively. The functions <code>dir</code> and <code>notdir</code> can be used to obtain a similar effect (see <a href="File-Name-Functions.html#File-Name-Functions">Functions for File Names</a>). Note, however, that the ‘<samp>D</samp>’ variants all omit the trailing slash which always appears in the output of the <code>dir</code> function.  Here is a table of the variants:</p>
<dl compact="compact">
<dd><span id="index-_0024_0028_0040D_0029"></span>
<span id="index-_0040D-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(@D)</samp>’</dt>
<dd><p>The directory part of the file name of the target, with the trailing
slash removed.  If the value of ‘<samp>$@</samp>’ is <samp>dir/foo.o</samp> then
‘<samp>$(@D)</samp>’ is <samp>dir</samp>.  This value is <samp>.</samp> if ‘<samp>$@</samp>’ does
not contain a slash.
</p>
<span id="index-_0024_0028_0040F_0029"></span>
<span id="index-_0040F-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(@F)</samp>’</dt>
<dd><p>The file-within-directory part of the file name of the target.  If the
value of ‘<samp>$@</samp>’ is <samp>dir/foo.o</samp> then ‘<samp>$(@F)</samp>’ is
<samp>foo.o</samp>.  ‘<samp>$(@F)</samp>’ is equivalent to ‘<samp>$(notdir $@)</samp>’.
</p>
<span id="index-_0024_0028_002aD_0029"></span>
<span id="index-_002aD-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(*D)</samp>’</dt>
<dd><span id="index-_0024_0028_002aF_0029"></span>
<span id="index-_002aF-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(*F)</samp>’</dt>
<dd><p>The directory part and the file-within-directory
part of the stem; <samp>dir</samp> and <samp>foo</samp> in this example.
</p>
<span id="index-_0024_0028_0025D_0029"></span>
<span id="index-_0025D-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(%D)</samp>’</dt>
<dd><span id="index-_0024_0028_0025F_0029"></span>
<span id="index-_0025F-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(%F)</samp>’</dt>

<dd><p>The directory part and the file-within-directory part of the target archive member name.  This makes sense only for archive member targets of the form <samp><var>archive</var>(<var>member</var>)</samp> and is useful only when <var>member</var> may contain a directory name.  (See Archive Members as Targets.)</p>

<span id="index-_0024_0028_003cD_0029"></span>
<span id="index-_003cD-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(&lt;D)</samp>’</dt>
<dd><span id="index-_0024_0028_003cF_0029"></span>
<span id="index-_003cF-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(&lt;F)</samp>’</dt>
<dd><p>The directory part and the file-within-directory
part of the first prerequisite.
</p>
<span id="index-_0024_0028_005eD_0029"></span>
<span id="index-_005eD-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(^D)</samp>’</dt>
<dd><span id="index-_0024_0028_005eF_0029"></span>
<span id="index-_005eF-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(^F)</samp>’</dt>
<dd><p>Lists of the directory parts and the file-within-directory
parts of all prerequisites.
</p>
<span id="index-_0024_0028_002bD_0029"></span>
<span id="index-_002bD-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(+D)</samp>’</dt>
<dd><span id="index-_0024_0028_002bF_0029"></span>
<span id="index-_002bF-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(+F)</samp>’</dt>
<dd><p>Lists of the directory parts and the file-within-directory
parts of all prerequisites, including multiple instances of duplicated
prerequisites.
</p>
<span id="index-_0024_0028_003fD_0029"></span>
<span id="index-_003fD-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(?D)</samp>’</dt>
<dd><span id="index-_0024_0028_003fF_0029"></span>
<span id="index-_003fF-_0028automatic-variable_0029"></span>
</dd>
<dt>‘<samp>$(?F)</samp>’</dt>
<dd><p>Lists of the directory parts and the file-within-directory parts of
all prerequisites that are newer than the target.
</p></dd>
</dl>

<p>Note that we use a special stylistic convention when we talk about these
automatic variables; we write “the value of ‘<samp>$&lt;</samp>’”, rather than
“the&nbsp;variable&nbsp;<code>&lt;</code>”<!-- /@w --> as we would write for ordinary variables
such as <code>objects</code> and <code>CFLAGS</code>.  We think this convention
looks more natural in this special case.  Please do not assume it has a
deep significance; ‘<samp>$&lt;</samp>’ refers to the variable named <code>&lt;</code> just
as ‘<samp>$(CFLAGS)</samp>’ refers to the variable named <code>CFLAGS</code>.
You could just as well use ‘<samp>$(&lt;)</samp>’ in place of ‘<samp>$&lt;</samp>’.
</p>

<h3>Examples of Makefiles</h3>

<pre>
CC = gcc #Which compiler to use
CFLAGS = -Wall #Which flags to use -ggdb -Wall etc..
LDFLAGS  = -lm #Which libraries to use -lm   -lefence   etc...
OBJFILES = stack.o main.o #Which object files arepart of the final program
TARGET   = stacktest #What to name the final prog

all: $(TARGET)
$(TARGET): $(OBJFILES)
	$(CC) $(CFLAGS) -o $(TARGET) $(OBJFILES) $(LDFLAGS) #There's a TAB at the beginning of the lane not several spaces
	
clean:rm -f $(OBJFILES) $(TARGET) *
</pre>

<p>For example, the target "clean" removes the "stack" and "prog". You can then run the make without target, which is the same as "make all".</p>

<h4>Example 2</h4>

<p><code>${SRCS:.c=.o}</code> means, take the variable value <code>${SRCS}</code>, which is a string composed of words separated by spaces, and for each word, replace the suffix .c with .o</p>

<h3>Makefile which installs in your .local</h3>

<pre>
CC = gcc
CFLAGS = -std=c99 -W -Wextra -Wall -Wshadow -Wconversion -O2

LIBS = `pkg-config --cflags --libs gtk+-3.0 gtksourceview-4` -laspell

SRCS = main.c activate.c litos.c dialogs.c search_replace.c popovers.c sourceview.c acels.c spell.c
OBJS = $(SRCS:.c=.o)
PREFIX ?= ~/.local
BINDIR ?= $(PREFIX)/bin/
DESKTOPDIR ?= $(PREFIX)/share/applications/
ICONDIR ?= $(PREFIX)/share/icons
TARGET = litos
ICON = litos.png
TARGETDATA = org.litos.gtk.desktop
#HEADERS = &lt;header files&gt;

%.o: %.c $(HEADERS)
	$(CC) -c -o $@ $< $(CFLAGS) $(LIBS)

$(TARGET): $(OBJS)
	$(CC) -o $@ $^ $(CFLAGS) $(LIBS)
clean:
	rm -f $(OBJS)
	rm -f $(DATADIR)$(TARGETDATA)
	rm -f $(ICONDIR)$(ICON)
install:
	install -D -t $(BINDIR) $(TARGET) #-D option allows to create the dir when it doesn't exist
	install -D -t $(DESKTOPDIR) $(TARGETDATA)
	install -D -t $(ICONDIR) $(ICON)
</pre>

<p>see also the <a href="../linux/install.html">install command</a> for clarifications.</p>

<section aria-label="End">
<a href="compiler.html">&#171;The gcc compiler</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</article>

</body>
</html>
