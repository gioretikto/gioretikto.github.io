<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="Editor"/>
    <title>Editor</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><p><a class="navbar" href="../../index.html">Home</a></p></li>
        <li><p><a class="navbar" href="index.html">Index</a></p></li>
    </ul>
</nav>
      
<div class="content">

<h1>Entering raw mode</h1>

<p>Let’s try and read keypresses from the user. (The lines you need to add are highlighted and marked with arrows.)</p>

<pre>
#include &lt;unistd.h&gt;
int main() {
	char c;
	while (read(STDIN_FILENO, &amp;c, 1) == 1);
	return 0;
	}
</pre>


<p><code>read()</code> and <code>STDIN_FILENO</code> come from <code>&lt;unistd.h&gt;</code>. We are asking <code>read()</code> to read <code>1</code> byte from the standard input into the variable <code>c</code>, and to keep doing it until there are no more bytes to read. <code>read()</code> returns the number of bytes that it read, and will return <code>0</code> when it reaches the end of a file.</p>

<p>When you run <code>./kilo</code>, your terminal gets hooked up to the standard input, and so your keyboard input gets read into the <code>c</code> variable. However, by default your terminal starts in <strong>canonical mode</strong>, also called <strong>cooked mode</strong>. In this mode, keyboard input is only sent to your program when the user presses <kbd>Enter</kbd>. This is useful for many programs: it lets the user type in a line of text, use <kbd>Backspace</kbd> to fix errors until they get their input exactly the way they want it, and finally press <kbd>Enter</kbd> to send it to the program. But it does not work well for programs with more complex user interfaces, like text editors. We want to process each keypress as it comes in, so we can respond to it immediately.</p>

<p>What we want is <strong>raw mode</strong>. Unfortunately, there is no simple switch you can flip to set the terminal to raw mode. Raw mode is achieved by turning off a great many flags in the terminal, which we will do gradually over the course of this chapter.</p>

<p>To exit the above program, press <kbd>Ctrl-D</kbd> to tell <code>read()</code> that it’s reached the end of file. Or you can always press <kbd>Ctrl-C</kbd> to signal the process to terminate immediately.</p>

<h2>Press <kbd>q</kbd> to quit?</h2>

<p>To demonstrate how canonical mode works, we’ll have the program exit when it reads a <kbd>q</kbd> keypress from the user. (Lines you need to change are highlighted and marked the same way as lines you need to add.)</p>

<pre>
#include &lt;unistd.h&gt;
int main() {
	char c;
	while (read(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; c != 'q');
	return 0;
}</pre>

<p>To quit this program, you will have to type a line of text that includes a <code>q</code> in it, and then press enter. The program will quickly read the line of text one character at a time until it reads the <code>q</code>, at which point the <code>while</code> loop will stop and the program will exit. Any characters after the <code>q</code> will be left unread on the input queue, and you may see that input being fed into your shell after your program exits.</p>

<h2>Turn off echoing</h2>

<p>We can set a terminal’s attributes by (1) using <code>tcgetattr()</code> to read the current attributes into a struct, (2) modifying the struct by hand, and (3) passing the modified struct to <code>tcsetattr()</code> to write the new terminal attributes back out. Let’s try turning off the <code>ECHO</code> feature this way.</p>

<pre>
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

void enableRawMode() {
	struct termios raw;
	tcgetattr(STDIN_FILENO, &amp;raw);
	raw.c_lflag &amp;= ~(ECHO);
	tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);
}
	
int main() {
	enableRawMode();
	char c;
	while (read(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; c != 'q');
	return 0;
}
</pre>

<p><code>struct termios</code>, <code>tcgetattr()</code>, <code>tcsetattr()</code>, <code>ECHO</code>, and <code>TCSAFLUSH</code> all come from <code>&lt;termios.h&gt;</code>.</p>

<p>The <code>ECHO</code> feature causes each key you type to be printed to the terminal, so you can see what you’re typing. This is useful in canonical mode, but really gets in the way when we are trying to carefully render a user interface in raw mode. So we turn it off. This program does the same thing as the one in the previous step, it just doesn’t print what you are typing. You may be familiar with this mode if you’ve ever had to type a password at the terminal, when using <code>sudo</code> for example.</p>

<p>After the program quits, depending on your shell, you may find your terminal is still not echoing what you type. Don’t worry, it will still listen to what you type. Just press <kbd>Ctrl-C</kbd> to start a fresh line of input to your shell, and type in <code>reset</code> and press <kbd>Enter</kbd>. This resets your terminal back to normal in most cases. Failing that, you can always restart your terminal emulator. We’ll fix this whole problem in the next step.</p>

<p>Terminal attributes can be read into a <code>termios</code> struct by <code>tcgetattr()</code>. After modifying them, you can then apply them to the terminal using <code>tcsetattr()</code>. The <code>TCSAFLUSH</code> argument specifies when to apply the change: in this case, it waits for all pending output to be written to the terminal, and also discards any input that hasn’t been read.</p>

<p>The <code>c_lflag</code> field is for “local flags”. A comment in macOS’s <code>&lt;termios.h&gt;</code> describes it as a “dumping ground for other state”. So perhaps it should be thought of as “miscellaneous flags”. The other flag fields are <code>c_iflag</code> (input flags), <code>c_oflag</code> (output flags), and <code>c_cflag</code> (control flags), all of which we will have to modify to enable raw mode.</p>

<p><code>ECHO</code> is a bitflag, defined as <code>00000000000000000000000000001000</code> in binary. We use the bitwise-NOT operator (<code>~</code>) on this value to get <code>11111111111111111111111111110111</code>. We then bitwise-AND this value with the flags field, which forces the fourth bit in the flags field to become <code>0</code>, and causes every other bit to retain its current value. Flipping bits like this is common in C.</p>

<h2>Disable raw mode at exit</h2>

<p>Let’s be nice to the user and restore their terminal’s original attributes when our program exits. We’ll save a copy of the <code>termios</code> struct in its original state, and use <code>tcsetattr()</code> to apply it to the terminal when the program exits.</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

struct termios orig_termios;

void disableRawMode() {
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
}

void enableRawMode() {
  tcgetattr(STDIN_FILENO, &orig_termios);
  atexit(disableRawMode);
  struct termios raw = orig_termios;
  raw.c_lflag &= ~(ECHO);
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

int main() {
	enableRawMode();
	char c;
	while (read(STDIN_FILENO, &c, 1) == 1 && c != 'q');
	disableRawMode();
	return 0;
}
</pre>

<p><code>atexit()</code> comes from <code>&lt;stdlib.h&gt;</code>. We use it to register our <code>disableRawMode()</code> function to be called automatically when the program exits, whether it exits by returning from <code>main()</code>, or by calling the <code>exit()</code> function. This way we can ensure we’ll leave the terminal attributes the way we found them when our program exits.</p>

<p>We store the original terminal attributes in a global variable, <code>orig_termios</code>. We assign the <code>orig_termios</code> struct to the <code>raw</code> struct in order to make a copy
of it before we start making our changes.</p>

<p>You may notice that leftover input is no longer fed into your shell after the program quits. This is because of the <code>TCSAFLUSH</code> option being passed to <code>tcsetattr()</code> when the program exits. As described earlier, it discards any unread input before applying the changes to the terminal. (Note: This doesn’t happen in Cygwin for some reason, but it won’t matter once we are reading input one byte at a time.)</p>

<h2>Turn off canonical mode</h2>

<p>There is an <code>ICANON</code> flag that allows us to turn off canonical mode. This means we will finally be reading input byte-by-byte, instead of line-by-line.</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
struct termios orig_termios;

void disableRawMode() { … }

void enableRawMode() {
  tcgetattr(STDIN_FILENO, &orig_termios);
  atexit(disableRawMode);
  struct termios raw = orig_termios;
  raw.c_lflag &= ~(ECHO | ICANON);
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

int main() { … }
</pre>

<p><code>ICANON</code> comes from <code>&lt;termios.h&gt;</code>. Input flags (the ones in the <code>c_iflag</code> field) generally start with <code>I</code> like <code>ICANON</code> does. However, <code>ICANON</code> is not an input flag, it’s a “local” flag in the <code>c_lflag</code> field. So that’s confusing.</p>

<p>Now the program will quit as soon as you press <kbd>q</kbd>.</p>

<h2>Display keypresses</h2>

<p>To get a better idea of how input in raw mode works, let’s print out each byte that we <code>read()</code>. We’ll print each character’s numeric ASCII value, as well as the character it represents if it is a printable character.</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
struct termios orig_termios;

void disableRawMode() { … }
void enableRawMode() { … }

int main() {
  enableRawMode();
  char c;
  while (read(STDIN_FILENO, &c, 1) == 1 && c != 'q') {
    if (iscntrl(c)) {
      printf("%d\n", c);
    } else {
      printf("%d ('%c')\n", c, c);
    }
  }
  disableRawMode();
  return 0;
}
</pre>

<p><code>iscntrl()</code> comes from <code>&lt;ctype.h&gt;</code>, and <code>printf()</code> comes from <code>&lt;stdio.h&gt;</code>.</p>

<p><code>iscntrl()</code> tests whether a character is a control character. Control characters are nonprintable characters that we don’t want to print to the screen. ASCII codes 0–31 are all control characters, and 127 is also a control character. ASCII codes 32–126 are all printable. (Check out the ASCII table</a> to see all of the characters.)</p>

<p><code>printf()</code> can print multiple representations of a byte. <code>%d</code> tells it to format the byte as a decimal number (its ASCII code), and <code>%c</code> tells it to write out the byte directly, as a character.</p>

<p>This is a very useful program. It shows us how various keypresses translate into the bytes we read. Most ordinary keys translate directly into the characters they represent. But try seeing what happens when you press the arrow keys, or <kbd>Escape</kbd>, or <kbd>Page Up</kbd>, or <kbd>Page Down</kbd>, or <kbd>Home</kbd>, or <kbd>End</kbd>, or <kbd>Backspace</kbd>, or <kbd>Delete</kbd>, or <kbd>Enter</kbd>. Try key combinations with <kbd>Ctrl</kbd>, like <kbd>Ctrl-A</kbd>, <kbd>Ctrl-B</kbd>, etc.</p>

<p>You’ll notice a few interesting things:</p>

<ul>
<li><p>Arrow keys, <kbd>Page Up</kbd>, <kbd>Page Down</kbd>, <kbd>Home</kbd>, and <kbd>End</kbd> all input 3 or 4 bytes to the terminal: <code>27</code>, <code>'['</code>, and then one or two other characters. This is known as an <em>escape sequence</em>. All escape sequences start with a <code>27</code> byte. Pressing <kbd>Escape</kbd> sends a single <code>27</code> byte as input.</p></li>
<li><p><kbd>Backspace</kbd> is byte <code>127</code>. <kbd>Delete</kbd> is a 4-byte escape sequence.</p></li>
<li><p><kbd>Enter</kbd> is byte <code>10</code>, which is a newline character, also known as <code>'\n'</code>.</p></li>
<li><p><kbd>Ctrl-A</kbd> is <code>1</code>, <kbd>Ctrl-B</kbd> is <code>2</code>, <kbd>Ctrl-C</kbd> is… oh, that terminates the program, right. But the <kbd>Ctrl</kbd> key combinations that do work seem to map the letters A–Z to the codes 1–26.</p></li>
</ul>

<p>By the way, if you happen to press <kbd>Ctrl-S</kbd>, you may find your program seems to be frozen. What you’ve done is you’ve asked your program to stop sending you output. Press <kbd>Ctrl-Q</kbd> to tell it to resume sending you output.</p>

<p>Also, if you press <kbd>Ctrl-Z</kbd> (or maybe <kbd>Ctrl-Y</kbd>), your program will be suspended to the background. Run the <code>fg</code> command to bring it back to the foreground. (It may quit immediately after you do that, as a result of <code>read()</code> returning <code>-1</code> to indicate that an error occurred. This happens on macOS, while Linux seems to be able to resume the <code>read()</code> call properly.)</p>

<h2>Turn off <kbd>Ctrl-C</kbd> and <kbd>Ctrl-Z</kbd> signals</h2>

<p>By default, <kbd>Ctrl-C</kbd> sends a <code>SIGINT</code> signal to the current process which causes it to terminate, and <kbd>Ctrl-Z</kbd> sends a <code>SIGTSTP</code> signal to the current process which causes it to suspend. Let’s turn off the sending of both of these signals.</p>

<pre>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
struct termios orig_termios;
void disableRawMode() { … }
void enableRawMode() {
	tcgetattr(STDIN_FILENO, &amp;orig_termios);
	atexit(disableRawMode); struct termios raw = orig_termios;
	raw.c_lflag &amp;= ~(ECHO | ICANON | ISIG);  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);
}
int main() { … }
</pre>

<p><code>ISIG</code> comes from <code>&lt;termios.h&gt;</code>. Like <code>ICANON</code>, it starts with <code>I</code> but isn’t an input flag.</p>

<p>Now <kbd>Ctrl-C</kbd> can be read as a <code>3</code> byte and <kbd>Ctrl-Z</kbd> can be read as a <code>26</code> byte.</p>

<p>This also disables <kbd>Ctrl-Y</kbd> on macOS, which is like <kbd>Ctrl-Z</kbd> except it waits for the program to read input before suspending it.</p>

<h2>Disable <kbd>Ctrl-S</kbd> and <kbd>Ctrl-Q</kbd></h2>

<p>By default, <kbd>Ctrl-S</kbd> and <kbd>Ctrl-Q</kbd> are used for software flow control. <kbd>Ctrl-S</kbd> stops data from being transmitted to the terminal until you press <kbd>Ctrl-Q</kbd>. This originates in the days when you might want to pause the transmission of data to let a device like a printer catch up. Let’s just turn off that feature.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void disableRawMode() { … }void enableRawMode() {  tcgetattr(STDIN_FILENO, &amp;orig_termios);  atexit(disableRawMode); struct termios raw = orig_termios;  raw.c_iflag &amp;= ~(IXON);  raw.c_lflag &amp;= ~(ECHO | ICANON | ISIG);  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);}int main() { … }</pre>

<p><code>IXON</code> comes from <code>&lt;termios.h&gt;</code>. The <code>I</code> stands for “input flag” (which it is, unlike the other <code>I</code> flags we’ve seen so far) and <code>XON</code> comes from the names of the two control characters that <kbd>Ctrl-S</kbd> and <kbd>Ctrl-Q</kbd> produce: <code>XOFF</code> to pause transmission and <code>XON</code> to resume transmission.</p>

<p>Now <kbd>Ctrl-S</kbd> can be read as a <code>19</code> byte and <kbd>Ctrl-Q</kbd> can be read as a <code>17</code> byte.</p>

<h2>Disable <kbd>Ctrl-V</kbd></h2>

<p>On some systems, when you type <kbd>Ctrl-V</kbd>, the terminal waits for you to type another character and then sends that character literally. For example, before we disabled <kbd>Ctrl-C</kbd>, you might’ve been able to type <kbd>Ctrl-V</kbd> and then <kbd>Ctrl-C</kbd> to input a <code>3</code> byte. We can turn off this feature using the <code>IEXTEN</code> flag.</p>

<p>Turning off <code>IEXTEN</code> also fixes <kbd>Ctrl-O</kbd> in macOS, whose terminal driver is otherwise set to discard that control character.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void disableRawMode() { … }void enableRawMode() {  tcgetattr(STDIN_FILENO, &amp;orig_termios);  atexit(disableRawMode); struct termios raw = orig_termios;  raw.c_iflag &amp;= ~(IXON);  raw.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);}int main() { … }</pre>

<p><code>IEXTEN</code> comes from <code>&lt;termios.h&gt;</code>. It is another flag that starts with <code>I</code> but belongs in the <code>c_lflag</code> field.</p>

<p><kbd>Ctrl-V</kbd> can now be read as a <code>22</code> byte, and <kbd>Ctrl-O</kbd> as a <code>15</code> byte.</p>

<h2>Fix <kbd>Ctrl-M</kbd></h2>

<p>If you run the program now and go through the whole alphabet while holding down <kbd>Ctrl</kbd>, you should see that we have every letter except <kbd>M</kbd>. <kbd>Ctrl-M</kbd> is weird: it’s being read as <code>10</code>, when we expect it to be read as <code>13</code>, since it is the 13th letter of the alphabet, and <kbd>Ctrl-J</kbd> already produces a <code>10</code>. What else produces <code>10</code>? The <kbd>Enter</kbd> key does.</p>

<p>It turns out that the terminal is helpfully translating any carriage returns (<code>13</code>, <code>'\r'</code>) inputted by the user into newlines (<code>10</code>, <code>'\n'</code>). Let’s turn
off this feature.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void disableRawMode() { … }void enableRawMode() {  tcgetattr(STDIN_FILENO, &amp;orig_termios);  atexit(disableRawMode); struct termios raw = orig_termios;  raw.c_iflag &amp;= ~(ICRNL | IXON);  raw.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);}int main() { … }</pre>

<p><code>ICRNL</code> comes from <code>&lt;termios.h&gt;</code>. The <code>I</code> stands for “input flag”, <code>CR</code> stands for “carriage return”, and <code>NL</code> stands for “new line”.</p>

<p>Now <kbd>Ctrl-M</kbd> is read as a <code>13</code> (carriage return), and the <kbd>Enter</kbd> key is also read as a <code>13</code>.</p>

<h2>Turn off all output processing</h2>

<p>It turns out that the terminal does a similar translation on the output side. It translates each newline (<code>"\n"</code>) we print into a carriage return followed by a newline (<code>"\r\n"</code>). The terminal requires both of these characters in order to start a new line of text. The carriage return moves the cursor back to the beginning of the current line, and the newline moves the cursor down a line, scrolling the screen if necessary. (These two distinct operations originated in the days of typewriters and teletypes.)</p>

<p>We will turn off all output processing features by turning off the <code>OPOST</code>
flag. In practice, the <code>"\n"</code> to <code>"\r\n"</code> translation is likely the only output
processing feature turned on by default.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void disableRawMode() { … }void enableRawMode() {  tcgetattr(STDIN_FILENO, &amp;orig_termios);  atexit(disableRawMode); struct termios raw = orig_termios;  raw.c_iflag &amp;= ~(ICRNL | IXON);  raw.c_oflag &amp;= ~(OPOST);  raw.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);}int main() { … }</pre>

<p><code>OPOST</code> comes from <code>&lt;termios.h&gt;</code>. <code>O</code> means it’s an output flag, and I assume <code>POST</code> stands for “post-processing of output”.</p>

<p>If you run the program now, you’ll see that the newline characters we’re printing are only moving the cursor down, and not to the left side of the screen. To fix that, let’s add carriage returns to our <code>printf()</code> statements.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void disableRawMode() { … }void enableRawMode() { … }int main() {  enableRawMode();  char c; while (read(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; c != 'q') {   if (iscntrl(c)) {      printf("%d\r\n", c);    }else {      printf("%d ('%c')\r\n", c, c);    }  } return 0;}</pre>

<p>From now on, we’ll have to write out the full <code>"\r\n"</code> whenever we want to start a new line.</p>

<h2>Miscellaneous flags</h2>

<p>Let’s turn off a few more flags.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void disableRawMode() { … }void enableRawMode() {  tcgetattr(STDIN_FILENO, &amp;orig_termios);  atexit(disableRawMode); struct termios raw = orig_termios; raw.c_iflag &amp;= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);  raw.c_oflag &amp;= ~(OPOST);  raw.c_cflag |= (CS8);  raw.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);}
int main() { … }</pre>

<p><code>BRKINT</code>, <code>INPCK</code>, <code>ISTRIP</code>, and <code>CS8</code> all come from <code>&lt;termios.h&gt;</code>.</p>

<p>This step probably won’t have any observable effect for you, because these flags are either already turned off, or they don’t really apply to modern terminal emulators. But at one time or another, switching them off was considered (by someone) to be part of enabling “raw mode”, so we carry on the tradition (of whoever that someone was) in our program.</p>

<p>As far as I can tell:</p>

<ul>
<li><p>When <code>BRKINT</code> is turned on, a break condition will cause a <code>SIGINT</code> signal to be sent to the program, like pressing <code>Ctrl-C</code>.</p></li>
<li><p><code>INPCK</code> enables parity checking, which doesn’t seem to apply to modern terminal emulators.</p></li>
<li><p><code>ISTRIP</code> causes the 8th bit of each input byte to be stripped, meaning it will set it to <code>0</code>. This is probably already turned off.</p></li>
<li><p><code>CS8</code> is not a flag, it is a bit mask with multiple bits, which we set using the bitwise-OR (<code>|</code>) operator unlike all the flags we are turning off. It sets the character size (CS) to 8 bits per byte. On my system, it’s already set that way.</p></li>
</ul>

<h2>A timeout for <code>read()</code></h2>

<p>Currently, <code>read()</code> will wait indefinitely for input from the keyboard before it returns. What if we want to do something like animate something on the screen while waiting for user input? We can set a timeout, so that <code>read()</code> returns if it doesn’t get any input for a certain amount of time.</p>

<pre>
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
struct termios orig_termios;
void disableRawMode() { … }
void enableRawMode() {  tcgetattr(STDIN_FILENO, &amp;orig_termios);  atexit(disableRawMode); struct termios raw = orig_termios;  raw.c_iflag &amp;= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);  raw.c_oflag &amp;= ~(OPOST);  raw.c_cflag |= (CS8);  raw.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);  raw.c_cc[VMIN] = 0;  raw.c_cc[VTIME] = 1;  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw);}
int main() {  enableRawMode();
	while (1) {
		char c = '\0';
		read(STDIN_FILENO, &amp;c, 1);
		if (iscntrl(c)) {
			printf("%d\r\n", c);
		}else {
		      printf("%d ('%c')\r\n", c, c);
		}
		
		if (c == 'q')
			break;
	}
    
    return 0;
    }
</pre>

<p><code>VMIN</code> and <code>VTIME</code> come from <code>&lt;termios.h&gt;</code>. They are indexes into the <code>c_cc</code> field, which stands for “control characters”, an array of bytes that control various terminal settings.</p>

<p>The <code>VMIN</code> value sets the minimum number of bytes of input needed before <code>read()</code> can return. We set it to <code>0</code> so that <code>read()</code> returns as soon as there is any input to be read. The <code>VTIME</code> value sets the maximum amount of time to wait before <code>read()</code> returns. It is in tenths of a second, so we set it to 1/10 of a second, or 100 milliseconds. If <code>read()</code> times out, it will return <code>0</code>, which makes sense because its usual return value is the number of bytes read.</p>

<p>When you run the program, you can see how often <code>read()</code> times out. If you don’t supply any input, <code>read()</code> returns without setting the <code>c</code> variable, which retains its <code>0</code> value and so you see <code>0</code>s getting printed out. If you type really fast, you can see that <code>read()</code> returns right away after each keypress, so it’s not like you can only read one keypress every tenth of a second.</p>

<p>If you’re using <strong>Bash on Windows</strong>, you may see that <code>read()</code> still blocks for input. It doesn’t seem to care about the <code>VTIME</code> value. Fortunately, this won’t make too big a difference in our text editor, as we’ll be basically blocking for input anyways.</p>

<h2>Error handling</h2>

<p><code>enableRawMode()</code> now gets us fully into raw mode. It’s time to clean up the code by adding some error handling.</p>

<p>First, we’ll add a <code>die()</code> function that prints an error message and exits the program.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void die(const char *s) {  perror(s);  exit(1);}void disableRawMode() { … }void enableRawMode() { … }int main() { … }</pre>

<p><code>perror()</code> comes from <code>&lt;stdio.h&gt;</code>, and <code>exit()</code> comes from <code>&lt;stdlib.h&gt;</code>.</p>

<p>Most C library functions that fail will set the global <code>errno</code> variable to indicate what the error was. <code>perror()</code> looks at the global <code>errno</code> variable and prints a descriptive error message for it. It also prints the string given to it before it prints the error message, which is meant to provide context about what part of your code caused the error.</p>

<p>After printing out the error message, we exit the program with an exit status of <code>1</code>, which indicates failure (as would any non-zero value).</p>

<p>Let’s check each of our library calls for failure, and call <code>die()</code> when they fail.</p>

<pre>#include &lt;ctype.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;struct termios orig_termios;void die(const char *s) { … }void disableRawMode() { if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;orig_termios) == -1)    die("tcsetattr");}void enableRawMode() { if (tcgetattr(STDIN_FILENO, &amp;orig_termios) == -1) die("tcgetattr");  atexit(disableRawMode); struct termios raw = orig_termios;  raw.c_iflag &amp;= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);  raw.c_oflag &amp;= ~(OPOST);  raw.c_cflag |= (CS8);  raw.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);  raw.c_cc[VMIN] = 0;  raw.c_cc[VTIME] = 1; if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;raw) == -1) die("tcsetattr");}int main() {  enableRawMode(); while (1) {    char c = '\0';   if (read(STDIN_FILENO, &amp;c, 1) == -1 &amp;&amp; errno != EAGAIN) die("read");   if (iscntrl(c)) {      printf("%d\r\n", c);    }else {      printf("%d ('%c')\r\n", c, c);    }   if (c == 'q')break;  } return 0;}</pre>

<p><code>errno</code> and <code>EAGAIN</code> come from <code>&lt;errno.h&gt;</code>.</p>

<p><code>tcsetattr()</code>, <code>tcgetattr()</code>, and <code>read()</code> all return <code>-1</code> on failure, and set the <code>errno</code> value to indicate the error.</p>

<p>In Cygwin, when <code>read()</code> times out it returns <code>-1</code> with an <code>errno</code> of <code>EAGAIN</code>, instead of just returning <code>0</code> like it’s supposed to. To make it work in Cygwin,
we won’t treat <code>EAGAIN</code> as an error.</p>

<p>An easy way to make <code>tcgetattr()</code> fail is to give your program a text file or a pipe as the standard input instead of your terminal. To give it a file as standard input, run <code>./kilo &lt;kilo.c</code>. To give it a pipe, run <code>echo test | ./kilo</code>. Both should result in the same error from <code>tcgetattr()</code>,
something like <code>Inappropriate ioctl for device</code>.</p>

<h2>Sections</h2>

<p>That just about concludes this chapter on entering raw mode. The last thing we’ll do now is split our code into sections. This will allow these diffs to be shorter, as each section that isn’t changed in a diff will be folded into a single line.</p>

<pre>
#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
/*** data ***/struct termios orig_termios;
/*** terminal ***/void die(const char *s) { … }
void disableRawMode() { … }
void enableRawMode() { … }
int main() { … }
</pre>

<p>In the <a href="03.rawInputAndOutput.html">next chapter</a>, we’ll do some more low-level terminal input/output handling, and use that to draw to the screen and allow the user to move the cursor around.</p>

<h2>Press Ctrl-Q to quit</h2>

<p>Last chapter we saw that the Ctrl key combined with the alphabetic keys seemed to map to bytes 1–26. We can use this to detect Ctrl key combinations and map them to different operations in our editor. We’ll start by mapping Ctrl-Q to the quit operation.</p>

<h3>Refactor keyboard input</h3>

<p>Let’s make a function for low-level keypress reading, and another function for mapping keypresses to editor operations. We’ll also stop printing out keypresses at this point.</p>

<pre>
/*Features: Introduce the Press Ctrl-Q to quit */

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

#define CTRL_KEY(q) ((q) & 0x1f)

void die(const char *s) {
  perror(s);
  exit(1);
}

struct termios orig_termios;

void disableRawMode() {
  if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios) == -1)
    die("tcsetattr");
}

void enableRawMode() {
  if (tcgetattr(STDIN_FILENO, &orig_termios) == -1) die("tcgetattr");
  atexit(disableRawMode);
  struct termios raw = orig_termios;
  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c_oflag &= ~(OPOST);
  raw.c_cflag |= (CS8);
  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c_cc[VMIN] = 0;
  raw.c_cc[VTIME] = 1;
  if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == -1) die("tcsetattr");
}

char editorReadKey() {
  int nread;
  char c;
  while ((nread = read(STDIN_FILENO, &c, 1)) != 1) {
    if (nread == -1 && errno != EAGAIN) die("read");
  }
  return c;
}

/*** input ***/
void editorProcessKeypress() {
  char c = editorReadKey();
  switch (c) {
    case CTRL_KEY('q'):
      exit(0);
      break;
  }
}

int main() {
  enableRawMode();
  
  while (1) {

    editorProcessKeypress();
  }
  disableRawMode();
  return 0;
}
</pre>

<p>The CTRL_KEY macro bitwise-ANDs a character with the value 00011111, in binary. (In C, you generally specify bitmasks using hexadecimal, since C doesn’t have binary literals, and hexadecimal is more concise and readable once you get used to it.) In other words, it sets the upper 3 bits of the character to 0. This mirrors what the Ctrl key does in the terminal: it strips bits 5 and 6 from whatever key you press in combination with Ctrl, and sends that. (By convention, bit numbering starts from 0.) The ASCII character set seems to be designed this way on purpose. (It is also similarly designed so that you can set and clear bit 5 to switch between lowercase and uppercase.)</p>

<p><code>editorReadKey()</code>’s job is to wait for one keypress, and return it. Later, we’ll expand this function to handle escape sequences, which involves reading multiple bytes that represent a single keypress, as is the case with the arrow keys.</p>

<p><code>editorProcessKeypress()</code> waits for a keypress, and then handles it. Later, it will map various Ctrl key combinations and other special keys to different editor functions, and insert any alphanumeric and other printable keys’ characters into the text that is being edited.</p>

<p>Note that editorReadKey() belongs in the /*** terminal ***/ section because it deals with low-level terminal input, whereas editorProcessKeypress() belongs in the new /*** input ***/ section because it deals with mapping keys to editor functions at a much higher level.</p>

<p>Now we have vastly simplified main(), and we will try to keep it that way.</p>


<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
      