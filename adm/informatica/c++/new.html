<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="new operator"/>
    <title>new operator</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.php">Home</a></li>
        <li><a class="navbar" href="../../documentation.html">Documentation</a></li>
    </ul>
</nav>
      
<div class="content">

<h1>new operator</h1>

<p>You allocate memory in the heap using the <code>new</code> operator. This operator returns a pointer to the newly allocated memory. The syntax for the new operator is as follows:</p>

<pre>new data_type ( constructor_args );</pre>

<p>Here data_type is any valid data type or class. To use this memory, you must assign it to a pointer variable. Keeping track of memory on the heap is where pointers come in really handy. For example, to create a Point object in the heap, you can do the following:</p>

<pre>Point* myPoint = new Point(2,4);</pre>

<p>If you are allocating a built-in type, like an int , you do not need the brackets:</p>

<pre>int* myInt = new int;</pre>

<p>Thatâ€™s really all there is to it. The new operator is actually very easy to use. All memory that you allocate with the new operator must be de-allocated with the delete operator when you are done with it. If you do not free the memory you use, this memory will not be available to use later in the program. Forgetting to free heap memory is called a memory leak, and you should always avoid it. The delete operator acts on a pointer to a section of memory allocated with the new operator. If the delete operator is used on anything else, it will cause an error. The syntax for the delete operator is as follows:</p>

<pre>delete pointer;</pre>

<p>For example, to free the memory allocated in the preceding examples, do the following:</p>

<pre>
delete myInt;
myInt = 0;
delete myPoint;
myPoint = 0;
</pre>

<p>Once you free the memory allocated with new, set the value of the pointer to 0. This ensures that you will not accidentally try to delete something that you have already deleted. A double delete can cause all sorts of problems when you try to run your program. Using the delete operator on 0 does nothing, so it is harmless.</p>

<p>One good way to ensure that your allocations and de-allocations match up is to have a class manage them. The allocation would take place in the constructor, and the de-allocation in the destructor. Here is an example of such a class:</p>

<pre>
class HeapPoint
{
public:
	HeapPoint(int x, int y);
	Point* get() { return thePoint; }
	~HeapPoint();
private:
	Point* thePoint;
};

HeapPoint::HeapPoint(int x, int y) : thePoint(new Point(x,y))
{}

HeapPoint::~HeapPoint()
{
	delete thePoint;
	thePoint = 0;
}
</pre>

<p>And now you could use this HeapPoint as follows:</p>

<pre>void myFunc()
{
HeapPoint myHeapPoint(2,4);
Point* myPoint = myHeapPoint.get();
// do stuff with myPoint
// no need to call delete! Called automatically!
}
</pre>

<p>Because <code>myHeapPoint</code> is a local variable, it is automatically destroyed when the function ends. This is because it is on the stack. When it is destroyed, its destructor will be called, which will de-allocate the dynamic memory. It is a good idea to build a class like this every time you use memory from the heap.</p>

<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="hello_world.html">Hello World &#187;</a>
</section>

</div>

</body>
</html>
