<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="Constructors"/>
    <title>Constructors</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.php">Home</a></li>
        <li><a class="navbar" href="../../documentation.html">Documentation</a></li>
    </ul>
</nav>
      
<div class="content">

<h1>Constructors</h1>

<p>A constructor is a <b>member function</b> (method) of a class which initializes objects of a class. In C++, Constructor is automatically called when
object (instance of class) create. Constructors are typically used to initialize member variables of the class.</p>

<p>A constructor is a special function that takes the name of the class and returns no value.
So, class Human would have a constructor that is declared like this:</p>

<pre>
class Human
{
public:
	Human(); // declaration of a constructor
};
</pre>

<p>This constructor can be implemented either inline within the class or externally outside the class declaration. An implementation (also called definition) inside the class looks
like this:</p>

<pre>
class Human
{
public:
	Human()
	{
		// constructor code here
	}
};
</pre>

<p>A variant enabling you to define the constructor outside the class’ declaration looks like this:</p>

<pre>
class Human
{
public:
	Human(); // constructor declaration
};

// constructor implementation (definition)
Human::Human()
{
	// constructor code here
}
</pre>

<p><b>Note</b> <code>::</code> is called the scope resolution operator. For example, <code>Human::dateOfBirth</code> is referring to variable dateOfBirth
declared within the scope of class <code>Human</code>. <code>::dateOfBirth</code>, on the other hand would refer to another variable <code>dateOfBirth</code> in a
global scope.</p>

<p>A constructor is different from normal functions (and called special functions) in following ways:</p>

<ul>
    <li><p>Constructor has same name as the class itself</p></li>
    <li><p>Constructors don’t have return type</p></li>
    <li><p>A constructor is automatically called when an object is created.</p></li>
    <li><p>If we do not specify a constructor, C++ compiler generates a default constructor for us (expects no parameters and has an empty body).</p></li>
</ul>

<h2>When and How to Use Constructors</h2>

<p>A constructor is always invoked during object creation, when an instance of a class is constructed. This makes a constructor a perfect place for you to initialize class member
variables such as integers, pointers, and so on to values you choose. Take a look at Listing 9.2 again. Note that if you had forgotten to SetAge() , the integer variable
Human::age may contain an unknown value as that variable has not been initialized (try it by commenting out Lines 28 and 31). Listing 9.3 uses constructors to implement a
better version of class Human , where variable age has been initialized.</p>

<pre>
#include <iostream>
#include <string>
using namespace std;

class Human
{
private:
	string name;
	int age;
	public:
		Human() // constructor
		{
			age = 1; // initialization
			cout &lt;&lt; "Constructed an instance of class Human" &lt;&lt; endl;
		}

	void SetName (string humansName)
	{
		name = humansName;
	}

	void SetAge(int humansAge)
	{
		age = humansAge;
	}

	void IntroduceSelf()
	{
		cout &lt;&lt; "I am " + name &lt;&lt; " and am ";
		cout &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl;
	}

};

int main()
{
	Human firstWoman;
	firstWoman.SetName("Eve");
	firstWoman.SetAge (28);
	firstWoman.IntroduceSelf();
}
</pre>

<p>Output ▼</p>

<pre>
Constructed an instance of class Human
I am Eve and am 28 years old
</pre>

<h2>Overloading Constructors</h2>

<p>Constructors can be overloaded just like functions. We can therefore write a constructor that requires Human to be instantiated with a name as a
 parameter, for example:</p>

<pre>
class Human
{
public:
	Human()
	{
		// default constructor code here
	}
	Human(string humansName)
	{
		// overloaded constructor code here
	}
};
</pre>

<p>The application of overloaded constructors is demonstrated by Listing 9.4 in creating an object of class Human with a name supplied at the time of
 construction.</p>
 
<pre>
#include <iostream>
#include <string>
using namespace std;

class Human
{
private:
string name;
int age;
	public:
	Human() // default constructor
	{
	age = 0; // initialized to ensure no junk value
	cout << "Default constructor: name and age not set" &lt;&lt; endl;
	}
	Human(string humansName, int humansAge) // overloaded
	{
		name = humansName;
		age = humansAge;
		cout << "Overloaded constructor creates ";
		cout << name << " of " << age << " years" << endl;
	}
};

int main()
{
	Human firstMan; // use default constructor
	Human firstWoman ("Eve", 20); // use overloaded constructor
}
</pre>

<p>Output ▼</p>

<pre>Default constructor: name and age not set
Overloaded constructor creates Eve of 20 years</pre>

<p>The two lines in <code>main()</code> create two instances of class <code>Human</code>. firstMan uses the default constructor while firstWoman uses the overloaded
constructor supplying name and age at instantiation. The output is the result of object construction only! You may appreciate that if class Human had chosen to not support
the default constructor, main() would’ve had no option but to construct every object of Human using the overloaded constructor that takes name and age as a prerequisite—
making it impossible to create a Human without supplying a name or age.</p>

<h3>Other examples</h3>

<p>It is possible to pass arguments to constructors. Typically, these arguments help initialize an object when it is created. To create a parameterized
 constructor, simply add parameters to it the way you would to any other function. When you define the constructor’s body, use the parameters to initialize the object.</p>

<pre>
#include &lt;iostream&gt;

using namespace std; 

class Point { 

	private:
		int x, y; 

	public: 

		Point(int x1, int y1)
		{
		    x = x1;
		    y = y1;
		} 

		int getX()
		{
		    return x;
		} 

		int getY()
		{
		    return y;
		} 

}; 

int main() 

{
    Point p1(10, 15);
    cout &lt;&lt; "p1.x = "&lt;&lt; p1.getX() &lt;&lt; ", p1.y = " &lt;&lt; p1.getY();
    return 0; 
} 
</pre>

<p>Output:</p>

<pre>
p1.x = 10, p1.y = 15
</pre>

<p>When an object is declared in a parameterized constructor, the initial values have to be passed as arguments to the constructor function. The normal way of object declaration may not work. The constructors can be called explicitly or implicitly.</p>

<h2>Initializer List</h2>

<p>Initializer List is used in initializing the data members of a class. The initializer list provides an expedited way to initialize class attributes. A constructor initializer list is a set of attribute initializers that appears between a colon and the opening brace of the constructor function body. </p>

<p>If the only purpose for a particular constructor is object attribute initialization then all initializations can be performed in an initializer list and the body of the constructor can remain empty.</p>

<p>There are three reasons for using an initializer list. First, when you simply want to initialize data members. Initializations performed in the initializer list are guaranteed to be performed before the body of the constructor executes. Second, when you need to call a base class constructor. This use of an initializer list in this regard will be discussed in greater detail in chapter 13. Last, when you need to initialize class or instance constants. Constants must be initialized in an initializer list since they must be initialized when they are created.</p>

<pre>
#include &lt;iostream&gt;
 
class Something
{
	private:
		int m_value1;
		double m_value2;
		char m_value3;
	 
	public:
		Something(int value1, double value2, char value3='c')
		    : m_value1(value1), m_value2(value2), m_value3(value3) // directly initialize our member variables
		{
		// No need for assignment here
		}
	 
		void print()
		{
		     std::cout &lt;&lt; "Something(" &lt;&lt; m_value1 &lt;&lt; ", " &lt;&lt; m_value2 &lt;&lt; ", " &lt;&lt; m_value3 &lt;&lt; ")\n";
		} 
};
 
int main()
{
    Something something(1, 2.2); // value1 = 1, value2=2.2, value3 gets default value 'c'
    something.print();
    return 0;
}
</pre>

<p>This prints:</p>

<pre>Something(1, 2.2, c)</pre>

<p>It is important to confront the previous code with the following code that produces the same result:</p>

<pre>
class Something
{
private:
    int m_value1;
    double m_value2;
    char m_value3;
 
public:
    Something()
    {
        // These are all assignments, not initializations
        m_value1 = 1;
        m_value2 = 2.2;
        m_value3 = 'c';
    }
};
</pre>

<p>As you have learned in previous lessons, some types of data (e.g. const and reference variables) <b>must</b> be initialized on the line they are declared. Consider the following example:</p>

<pre>	
class Something
{
	private:
		const int m_value;
	 
	public:
		Something()
		{
		    m_value = 1; // error: const vars can not be assigned to
		} 
};
</pre>

<p>This produces code similar to the following:</p>

<pre>
const int m_value; // error: const vars must be initialized with a value
m_value = 5; //  error: const vars can not be assigned to
</pre>

<p><i>const</i> data members must be initialized using Initializer List.</p>

<pre>
#include &lt;iostream&gt;
using namespace std; 
  
class Test { 
    const int t; 
public: 
    Test(int t):t(t) {}  //Initializer list must be used 
    int getT() { return t; } 
}; 
  
int main() { 
    Test t1(10); 
    cout&lt;&lt;t1.getT(); 
    return 0; 
} 
  
/* OUTPUT: 
   10  
*/
</pre>

<h2>Uniform initialization in C++11</h2>

<p>In C++11, instead of direct initialization, uniform initialization can be used:

<pre>	
class Something
{
	private:
		const int m_value;
	 
	public:
		Something(): m_value { 5 } // Uniformly initialize our member variables
		{
		} 
};
</pre>

<p>We strongly encourage you to begin using this new syntax (even if you aren’t using const or reference member variables) as initialization lists are required when doing composition and inheritance (subjects we will be covering shortly).</p>

<p>In C++11, you can fully initialize a member array using uniform initialization:</p>

<pre>
class Something
{
private:
    const int m_array[5];
 
public:
    Something(): m_array { 1, 2, 3, 4, 5 } // use uniform initialization to initialize our member array
    {
    }
 
};
</pre>

<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="hello_world.html">Hello World &#187;</a>
</section>

</div>

</body>
</html>
