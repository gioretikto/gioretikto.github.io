<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Linux abstraction layers"/>
    <title>Linux abstraction layers</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Index</a></li>
    </ul>
</nav>

<div class="content">

<h1>Linux abstraction layers</h1>

<p>A Linux system is generally organized on three major levels: the <b>hardware level</b>, <b>kernel level</b>, and <b>user space level</b>. The <b>hardware level</b>, which comprises all the hardware components, including CPU, RAM, controllers, hard drives, SSDs, monitors, and peripherals; the <b>kernel level</b>, which comprises millions of lines of code mostly written in C that also contain the device drivers; and the <b>user level</b>, which is the place where all the applications, services, and daemons are running, along with the GUI and the shells:</p>

<p>The hardware level contains the hardware components of your machine, such as the memory (RAM), Central Processing Unit (CPU), and devices including disks, network interfaces, ports, and controllers. The memory is divided into two separate regions, called <b>kernel space</b> and <b>user space</b>.</p>

<p>The kernel is the beating heart of the Linux operating system. The kernel resides inside the memory (RAM) and manages all the hardware components. It is the interface between the software and hardware on your Linux system. The user space level is the level where user processes are executed. A process is a running instance of a program. How does all this work? Well, the memory, known as RAM, consists of cells that are used to store information temporarily. Those cells are accessed by different programs that are executed and function as an intermediary between the CPU and the storage. The speeds of accessing memory are very high in order to secure a seamless process of execution. The management of user processes inside the user space is the kernel's job. The kernel makes sure that none of the processes will interfere with each other. The kernel space is usually accessed only by the kernel, but there are times when user processes need to access this space. This is done through <b>system calls</b>. Basically, a system call is the way a user process requests a kernel service through an active process inside the kernel space, for anything such as <b>input/output (I/O)</b> requests to internal or external devices. All those requests are transferring data to and from the CPU, through RAM, in order to get the job done.</p>

<p>Devices are managed by the kernel. To sum up, the kernel is in charge of managing processes, system calls, memory, and devices. When dealing with devices, the kernel is managing device drivers, which are the interface between hardware components and software. All devices are accessible only in kernel mode, for a more secure and streamlined operation.</p>

<h2>Device files and naming conventions</h2>

<div id="udev">

<p>After seeing how those abstraction layers work, you may be wondering how Linux manages devices. Well, it does that with the help of <b>udev</b> (called user space <code>/dev</code>), which is a device manager for the kernel. It works with <b>device nodes</b>, which are special files (also called <b>device files</b>) used as an interface to the driver.</p>

<p><code>udev</code> runs as a daemon that listens to the user space calls that the kernel is sending, and so is aware of what kinds of devices are used and how they are used. The daemon is called udevd and its configurations are currently available under <code>/etc/udev/udev.conf</code>. Each Linux distribution has a default set of rules that governs <i>udevd</i>. Those rules are normally stored under the <code>/etc/udev/rules.d/</code> directory, as shown in the following listing:</p>

<pre>
$ cat /etc/udev/udev.conf .
# see udev.conf(5) for details
#
# udevd is also started in the initrd.  When this file is modified you might
# also want to rebuild the initrd, so that it will include the modified configuration.

#udev_log=info
#children_max=
#exec_delay=
#event_timeout=180
#timeout_signal=SIGKILL
#resolve_names=early
cat: .: Is a directory
</pre>

<p>Just by way of general information, the kernel sends calls for events using the <b>netlink</b> socket. The netlink socket is an interface for inter-process communication used for both user space and kernel space processes alike.</p>

<p>The /dev directory is the interface between user processes and devices managed by the kernel. If you were to use the <code>ls -la /dev</code> command, you will see a lot of files inside, each having different names. If you were to do a long listing, you would see different file types. Some of the files will start with the letters <b>b</b> and <b>c</b>, but the letters <b>p</b> and <b>s</b> may also be present, depending on your system. Files starting with those letters are device files. The ones starting with <b>b</b> are block devices, and those starting with the letter <b>c</b> are character devices. You can run the following command to see what types of device files are inside your <i>/dev</i> directory:</p>

<pre>ls -la /dev</pre>

<p>Block devices can be accessed by software only in fixed sizes. As you will see in the next listing the disk devices sda and sdb are represented as block devices. Block devices have a fixed size that can easily be indexed. Character devices, on the other hand, can be accessed using data streams, as they don't have a size like block devices. For example, printers are represented as character devices. In next listing, <code>sg0</code> and <code>sg1</code> are SCSI generic devices, and not assigned to any disks in our case:</p>

<p>Linux uses a device name convention that makes device management easier and consistent throughout the Linux ecosystem. udev uses a number of specific naming schemes that, by default, assign fixed names to devices. Those names are somehow standardized for device categories. For example, when naming network devices, the kernel uses information compiled from sources such as firmware, topology, and location. On a Red Hat-based system such as CentOS, there are five schemes used for naming a network interface, and we encourage you to visit these on the Red Hat customer portal official documentation website. <br> You could also check what udev rules are active on your system. On a CentOS 8 distribution, they are stored in the <code>/lib/udev/rules.d/</code> directory:</p>

<p>When it comes to hard drives or external drives, the conventions are more streamlined. Here are some examples:</p>

<ul>
	<li><p><b>For classic IDE drivers used for ATA drives</b>: hda (the master device), <i>hdb</i> (the slave device on the first channel), <i>hdc</i> (the master device on the second channel), and <i>hdd</i> (the slave device on the second channel)</p></li>

	<li><p><b>For NVMe drivers</b>: <i>nvme0</i> (the first device controller – character device), <i>nvme0n1</i> (first namespace – block device), and <i>nvme0n1p1</i> (first namespace, first partition – block device)</p></li>

	<li><p><b>For MMC drivers</b>: <i>mmcblk</i> (for SD cards using eMMC chips), <i>mmcblk0</i> (first device), and <i>mmcblk0p1</i> (first device, first partition)</p></li>

	<li><p><b>For SCSI drivers used for modern SATA or USB</b>: <i>sd</i> (for mass storage devices), <i>sda</i> (for the first registered device), <i>sdb</i> (for the second registered device), <i>sdc</i> (for the third registered device), and so on, and <i>sg</i> (for generic SCSI layers – character device)</p></li>

</ul>

<p>The devices that we are mostly interested in as regards this chapter are the mass storage devices. Those devices are usually <b>hard disk drives (HDD)</b> or <b>solid-state drives (SSD)</b> used inside your computer to store data. Those drives are most likely divided into partitions having a specific structure provided by the filesystem. We talked a little bit about filesystems earlier in this book in Chapter 2, The Linux Filesystem, when we referred to the Linux directory structure, but now it is time to get into more details about how
disks work inside a Linux system.</p>

</div> <!-- End <div id="udev"> -->

<section aria-label="End">
<a href="epoxides.html">&#171;Epoxides</a>
<a href="index.html">Index</a>
<a href="sulfides.html">Sulfides&#187;</a>
</section>

</div>

</body>
</html>
