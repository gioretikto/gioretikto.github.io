<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="GFile"/>
    <title>GFile</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Index</a></li>
    </ul>
</nav>

<div class="content">

<h1>GFile</h1>

<h2>Detailed Description</h2>

<p><code>GFile</code> is a high level abstraction for manipulating files on a virtual file system. <code>GFile</code>s are lightweight, immutable objects that do no I/O upon creation. It is necessary to understand that <code>GFile</code> objects do not represent files, merely an identifier for a file. All file content I/O is implemented as streaming operations (see <code>GInputStream<</code> and <code>GOutputStream</code>). To construct a <code>GFile</code>, you can use: <code>gFileNewForPath</code> if you have a path. <code>gFileNewForUri</code> if you have a URI. <code>gFileNewForCommandlineArg</code> for a command line argument. <code>gFileParseName</code> from a utf8 string gotten from <code>gFileGetParseName</code>. One way to think of <b>a GFile is as an abstraction of a pathname</b>. For normal files the system pathname is what is stored internally, but as <code>GFile</code>s are extensible it could also be something else that corresponds to a pathname in a userspace implementation of a filesystem. <code>GFile</code>s make up hierarchies of directories and files that correspond to the files on a filesystem. You can move through the file system with <code>GFile</code> using <code>gFileGetParent</code> to get an identifier for the parent directory, <code>gFileGetChild</code> to get a child within a directory, <code>gFileResolveRelativePath</code> to resolve a relative path between two <code>GFile</code>s. There can be multiple hierarchies, so you may not end up at the same root if you repeatedly call <code>gFileGetParent</code> on two different files. All <code>GFile</code>s have a basename (get with <code>gFileGetBasename</code>). These names are byte strings that are used to identify the file on the filesystem (relative to its parent directory) and there is no guarantees that they have any particular charset encoding or even make any sense at all. If you want to use filenames in a user interface you should use the display name that you can get by requesting the <code>G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME</code> attribute with <code>gFileQueryInfo</code>. This is guaranteed to be in utf8 and can be used in a user interface. But always store the real basename or the <code>GFile</code> to use to actually access the file, because there is no way to go from a display name to the actual name. Using <code>GFile</code> as an identifier has the same weaknesses as using a path in that there may be multiple aliases for the same file. For instance, hard or soft links may cause two different <code>GFile</code>s to refer to the same file. Other possible causes for aliases are: case insensitive filesystems, short and long names on Fat/NTFS, or bind mounts in Linux. If you want to check if two <code>GFile</code>s point to the same file you can query for the <code>G_FILE_ATTRIBUTE_ID_FILE</code> attribute. Note that <code>GFile</code> does some trivial canonicalization of pathnames passed in, so that trivial differences in the path string used at creation (duplicated slashes, slash at end of path, "." or ".." path segments, etc) does not create different <code>GFile</code>s. Many <code>GFile</code> operations have both synchronous and asynchronous versions to suit your application. Asynchronous versions of synchronous functions simply have <code>async()</code> appended to their function names. The asynchronous I/O functions call a <code>GAsyncReadyCallback</code> which is then used to finalize the operation, producing a GAsyncResult which is then passed to the function's matching <code>finish()</code> operation. Some <code>GFile</code> operations do not have synchronous analogs, as they may take a very long time to finish, and blocking may leave an application unusable. Notable cases include:<code>gFileMountMountable</code> to mount a mountable file. <code>gFileUnmountMountableWithOperation</code> to unmount a mountable file. <code>gFileEjectMountableWithOperation></code> to eject a mountable file. One notable feature of <code>GFile</code>s are entity tags, or "etags" for short. Entity tags are somewhat like a more abstract version of the traditional mtime, and can be used to quickly determine if the file has been modified from the version on the file system. See the HTTP 1.1 specification (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP Etag headers, which are a very similar concept.</p>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="hello_world.html">Hello World &#187;</a>
</section>

</div>

</body>
</html>
