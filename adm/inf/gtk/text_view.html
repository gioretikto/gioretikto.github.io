<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Text Widget Overview"/>
    <title>Text Widget Overview</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Index</a></li>
    </ul>
</nav>

<div class="content">

<h1>Text Widget Overview</h1>

<p>The <i>GtkTextBuffer</i> is an object for storing text. The <i>GtkTextView</i> object contains a <i>GtkTextBuffer</i> object. GtkTextView widget is used for displaying and editing multiline text. </p>

<h3>UTF-8 and GTK+</h3>

<p>GTK+ handles text in UTF-8 format. For the uninitiated, the UTF-8 is an ASCII compatible multi-byte unicode encoding. The thing to be noted is that one character can be encoded as multiple bytes. The GTK+ manual uses the term offset for character counts, and uses the term index for byte counts. The len argument of the gtk_text_buffer_set_text function is the length of the text in bytes. </p>

<h2>Tags</h2>

<p>Text in a buffer can be marked with tags. A tag is an attribute that can be applied to some range of text. For example, a tag might be called “bold” and make the text inside the tag bold. However, the tag concept is more general than that; tags don’t have to affect appearance. They can instead affect the behavior of mouse and key presses, “lock” a range of text so the user can’t edit it, or countless other things. A tag is represented by a <code>GtkTextTag</code> object. One <code>GtkTextTag</code> can be applied to any number of text ranges in any number of buffers.</p>

<p>Each tag is stored in a <code>GtkTextTagTable</code>. A tag table defines a set of tags that can be used together. Each buffer has one tag table associated with it; only tags from that tag table can be used with the buffer. A single tag table can be shared between multiple buffers, however.</p>

<p>Tags can have names, which is convenient sometimes (for example, you can name your tag that makes things bold “bold”), but they can also be anonymous (which is convenient if you’re creating tags on-the-fly).</p>

<h2>Text Iterators and Marks</h2>

<p>Most text manipulation is accomplished with iterators, represented by a <code>GtkTextIter</code>. An iterator represents a position between two characters in the text buffer. <code>GtkTextIter</code> is a struct designed to be allocated on the stack; it’s guaranteed to be copiable by value and never contain any heap-allocated data. Iterators are not valid indefinitely; whenever the buffer is modified in a way that affects the number of characters in the buffer, all outstanding iterators become invalid. (Note that deleting 5 characters and then reinserting 5 still invalidates iterators, though you end up with the same number of characters you pass through a state with a different number).</p>

<p>Because of this, iterators can’t be used to preserve positions across buffer modifications. To preserve a position, the <code>GtkTextMark</code> object is ideal. You can think of a mark as an invisible cursor or insertion point; it floats in the buffer, saving a position. If the text surrounding the mark is deleted, the mark remains in the position the text once occupied; if text is inserted at the mark, the mark ends up either to the left or to the right of the new text, depending on its gravity. The standard text cursor in left-to-right languages is a mark with right gravity, because it stays to the right of inserted text.</p>

<p>For example, if the text on both the left and right sides of a mark is deleted, the mark stays in the position that the text occupied. To be concrete, suppose that we represent the mark by a vertical bar
and that a text fragment in the buffer looks like this:</p>

<pre>abcde|fghijkl</pre>

<p>with the mark between the "e" and the "f" (no space in between). If the string "defgh" is deleted, the text becomes</p>

<pre>abc|ijkl</pre>

<p>If text is inserted at the mark, the mark ends up either to the left or to the right of the new text, depending on its gravity. The standard text cursor in left-to-right languages is a mark with right gravity, because it stays to the right of inserted text.</p>

<p>Like tags, marks can be either named or anonymous. There are two marks built-in to <code>GtkTextBuffer</code>; these are named “insert” and “selection_bound” and refer to the insertion point and the boundary of the selection which is not the insertion point, respectively. If no text is selected, these two marks will be in the same position. You can manipulate what is selected and where the cursor appears by moving these marks around.</p>



<pre>
#include &lt;gtk/gtk.h&gt;

void
on_window_destroy (GtkWidget *widget, gpointer data)
{
	gtk_main_quit ();
}

/* Callback for close button */
void
on_button_clicked (GtkWidget *button, GtkTextBuffer *buffer)
{
	GtkTextIter start;
	GtkTextIter end;

	gchar *text;

	/* Obtain iters for the start and end of points of the buffer */
	gtk_text_buffer_get_start_iter (buffer, &start);
	gtk_text_buffer_get_end_iter (buffer, &end);

	/* Get the entire buffer text. */
	text = gtk_text_buffer_get_text (buffer, &start, &end, FALSE);

	/* Print the text */
	g_print ("%s", text);

	g_free (text);

	gtk_main_quit ();
}

int 
main(int argc, char *argv[])
{
	GtkWidget *window;
	GtkWidget *vbox;
	GtkWidget *text_view;
	GtkWidget *button;
	GtkTextBuffer *buffer;
	GtkCssProvider *provider;
	GtkStyleContext *context;

	gtk_init (&argc, &argv);

	/* Create a Window. */
	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title (GTK_WINDOW (window), "Simple Multiline Text Editor");

	/* Set a decent default size for the window. */
	gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);
	g_signal_connect (G_OBJECT (window), "destroy", 
	G_CALLBACK (on_window_destroy),
	NULL);

	vbox = gtk_button_box_new (GTK_ORIENTATION_HORIZONTAL);
	gtk_container_add (GTK_CONTAINER (window), vbox);

	/* Create a multiline text widget. */
	text_view = gtk_text_view_new ();
	gtk_container_add (GTK_CONTAINER (vbox), text_view);

  	provider = gtk_css_provider_new ();
 	gtk_css_provider_load_from_data (provider,
		"textview{"
		"font-size: 30px;"
		"font-family: serif;"
	 	"} text{"
		"color: green;"
	    "background: black;"
	 	"}",	 	
	 	-1,
		 NULL);
	context = gtk_widget_get_style_context (text_view);
	gtk_style_context_add_provider (context,
	GTK_STYLE_PROVIDER (provider),
	GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);

	/* Obtaining the buffer associated with the widget. */
	buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (text_view));
	/* Set the default buffer text. */ 
	gtk_text_buffer_set_text (buffer, "Hello Text View!", -1);

	/* Create a close button. */
	button = gtk_button_new_with_label ("Close");

	g_signal_connect (G_OBJECT (button), "clicked", 
	G_CALLBACK (on_button_clicked),
	buffer);

	gtk_widget_show_all (window);

	gtk_main ();
	return 0;
}

</pre>

Formatted Text in GtkTextView</a></h2>

<p><var>GtkTextView</var> can also be used to display formatted text. This usually involves creating tags which represent a group of attributes and then applying them to a range of text.
</p>

<p>Tag objects are associated with a buffer and are created using thefollowing function,</p>

<pre>
GtkTextTag* gtk_text_buffer_create_tag( GtkTextBuffer *buffer,
                                        const gchar   *tag_name,
                                        const gchar   *first_prop_name,
                                        ... );
</pre>

<p>Tags can be optionally associated with a name <var>tag_name</var>. Thus, the tag could be referred using the returned pointer or using the <var>tag_name</var>. For anonymous tags, <var>NULL</var> is passed to <var>tag_name</var>. The group of properties represented by this tag is listed as name/value pairs after the <var>tag_name</var>. The list of property/value pairs is terminated with a <var>NULL</var> pointer. <var>"style"</var>, <var>"weight"</var>, <var>"editable"</var>, <var>"justification"</var> are some common property names. The following table lists their meaning and assignable values. <p>
</p>

<div class="table"
><a name="AEN129"></a><p><b>Table 1. Common properties used for creating tags</b></p>

<table frame="border" rules="all" class="CALSTABLE" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property</th><th>Meaning</th><th>Values</th></tr></thead><tbody><tr><td><var>"style"</var></td><td>Font style as <var>PangoStyle</var>.</td><td>
<p></p><table border="0"><tbody><tr><td><var>PANGO_STYLE_NORMAL</var></td></tr><tr><td><var>PANGO_STYLE_OBLIQUE</var></td></tr><tr><td><var>PANGO_STYLE_ITALIC</var></td></tr></tbody></table><p></p>
</td></tr><tr><td><var>"weight"</var></td><td>Font weight as integer.</td><td>
<p></p><table border="0"><tbody><tr><td><var>PANGO_WEIGHT_NORMAL</var></td></tr><tr><td><var>PANGO_WEIGHT_BOLD</var></td></tr></tbody></table><p></p>
</td></tr><tr><td><var>"editable"</var></td><td>Text modifiable by user.</td><td>
<p></p><table border="0"><tbody><tr><td><var>TRUE</var></td></tr><tr><td><var>FALSE</var></td></tr></tbody></table><p></p>
</td></tr><tr><td><var>"justification"</var></td><td>Justification of text.</td><td>
<p></p><table border="0"><tbody><tr><td><var>GTK_JUSTIFY_LEFT</var></td></tr><tr><td><var>GTK_JUSTIFY_RIGHT</var></td></tr><tr><td><var>GTK_JUSTIFY_CENTER</var></td></tr><tr><td><var>GTK_JUSTIFY_FILL</var></td></tr></tbody></table><p></p>
</td></tr><tr><td><var>"foreground"</var></td><td>Foreground color of text.</td><td><var>"#RRGGBB"</var></td></tr><tr><td><var>"background"</var></td><td>Background color of text.</td><td><var>"#RRGGBB"</var></td></tr><tr><td><var>"wrap-mode"</var></td><td>Text wrapping mode</td><td>
<p></p><table border="0"><tbody><tr><td>
<var>GTK_WRAP_NONE</var> - Don't wrap text
</td></tr><tr><td>
<var>GTK_WRAP_CHAR</var> - Wrap text, breaking in between characters
</td></tr><tr><td>
<var>GTK_WRAP_WORD</var> - Wrap text, breaking in between words
</td></tr><tr><td>
<var>GTK_WRAP_WORD_CHAR</var> - Wrap text, breaking in words,
or if that is not enough, also between characters</td></tr></tbody></table><p></p>
</td></tr><tr><td><var>"font"</var></td><td>Text font specified by font description string.</td><td>
<var>"[FAMILY-LIST] [STYLE-OPTIONS] [SIZE]"</var></td></tr>
</table>

<p>The created tag can then be applied to a range of text using the following functions,</p>

<pre>
void gtk_text_buffer_apply_tag( GtkTextBuffer     *buffer,
                                GtkTextTag        *tag,
                                const GtkTextIter *start,
                                const GtkTextIter *end );

</pre>

<pre>
void gtk_text_buffer_apply_tag_by_name( GtkTextBuffer     *buffer,
                                        const gchar       *name
                                        const GtkTextIter *start,
                                        const GtkTextIter *end );
</pre>

<p>The first function specifies the tag to be applied by a tag object and the second function specifies the tag by it's name. The range of text over with the tag is to applies is specified by the start and end iters.</p>

<pre>
#include &lt;gtk/gtk.h&gt;

void
on_window_destroy (GtkWidget *widget, gpointer data)
{
  gtk_main_quit ();
}

/* Callback for buttons in the toolbar. */
void
on_format_button_clicked (GtkWidget *button, GtkTextBuffer *buffer)
{
  GtkTextIter start, end;
  gchar *tag_name;

  /* Get iters at the beginning and end of current selection. */
  gtk_text_buffer_get_selection_bounds (buffer, &start, &end);
  /* Find out what tag to apply. The key "tag" is set to the
     appropriate tag name when the button widget was created. */
  tag_name = g_object_get_data (G_OBJECT (button), "tag");
  /* Apply the tag to the selected text. */
  gtk_text_buffer_apply_tag_by_name (buffer, tag_name, &start, &end);
}

/* Callback for the close button. */
void
on_close_button_clicked (GtkWidget *button, GtkTextBuffer *buffer)
{
  GtkTextIter start;
  GtkTextIter end;

  gchar *text;

  /* Get iters at the beginning and end of the buffer. */
  gtk_text_buffer_get_bounds (buffer, &start, &end);
  /* Retrieve the text. */
  text = gtk_text_buffer_get_text (buffer, &start, &end, FALSE);
  /* Print the text. */
  g_print ("%s", text);

  g_free (text);

  gtk_main_quit ();
}

int 
main(int argc, char *argv[])
{
  GtkWidget *window;
  GtkWidget *vbox;
  GtkWidget *bbox;

  GtkWidget *bold_button;
  GtkWidget *italic_button;
  GtkWidget *font_button;

  GtkWidget *text_view;
  GtkTextBuffer *buffer;

  GtkWidget *close_button;
  
  gtk_init (&argc, &argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title (GTK_WINDOW (window), "Formatted multiline text widget");
  gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);
  g_signal_connect (G_OBJECT (window), "destroy", 
                    G_CALLBACK (on_window_destroy),
                    NULL);

  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL,0);
  gtk_container_add (GTK_CONTAINER (window), vbox);

  /* Create a button box that will serve as a toolbar. */
  bbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL,0);
  gtk_container_add(GTK_CONTAINER (vbox), bbox);

  /* Create the text view widget and set some default text. */
  text_view = gtk_text_view_new ();
  
  gtk_container_add(GTK_CONTAINER (vbox), text_view);

  buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (text_view));
  gtk_text_buffer_set_text (buffer, "Hello Text View!", -1);

  /* Create tags associated with the buffer. */
  /* Tag with weight bold and tag name "bold" . */
  gtk_text_buffer_create_tag (buffer, "bold", 
                              "weight", PANGO_WEIGHT_BOLD, 
                              NULL);
  /* Tag with style italic and tag name "italic". */
  gtk_text_buffer_create_tag (buffer, "italic",
                              "style", PANGO_STYLE_ITALIC,
                              NULL);
  /* Tag with font fixed and tag name "font". */
  gtk_text_buffer_create_tag (buffer, "font",
                              "font", "fixed", 
                              NULL); 

  /* Create button for bold and add them the to the tool bar. */
  bold_button = gtk_button_new_with_label ("Bold");
  gtk_container_add (GTK_CONTAINER (bbox), bold_button);
  /* Connect the common signal handler on_format_button_clicked. This
     signal handler is common to all the buttons. A key called "tag"
     is associated with the buttons, which speicifies the tag name
     that the button is supposed to apply. The handler reads this key
     and applies the appropriate tag. Thus only one handler is needed
     for any number of buttons in the toolbar. */
  g_signal_connect (G_OBJECT (bold_button), "clicked",
                    G_CALLBACK (on_format_button_clicked),
                    buffer);
  g_object_set_data (G_OBJECT (bold_button), "tag", "bold");

  /* Create button for italic. */
  italic_button = gtk_button_new_with_label ("Italic");
  gtk_container_add (GTK_CONTAINER (bbox), italic_button);
  g_signal_connect (G_OBJECT (italic_button), "clicked",
                    G_CALLBACK (on_format_button_clicked),
                    buffer);
  g_object_set_data (G_OBJECT (italic_button), "tag", "italic");

  /* Create button for fixed font. */
  font_button = gtk_button_new_with_label ("Font Fixed");
  gtk_container_add (GTK_CONTAINER (bbox), font_button);
  g_signal_connect (G_OBJECT (font_button), "clicked",
                    G_CALLBACK (on_format_button_clicked),
                    buffer);
  g_object_set_data (G_OBJECT (font_button), "tag", "font");
  
  /* Create the close button. */
  close_button = gtk_button_new_with_label ("Close");
  
  gtk_container_add(GTK_CONTAINER (vbox), close_button);
  g_signal_connect (G_OBJECT (close_button), "clicked", 
                    G_CALLBACK (on_close_button_clicked),
                    buffer);

  gtk_widget_show_all (window);

  gtk_main ();
  return 0;
}
</pre>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="text_view_seach.html">Searching&#187;</a>
</section>

</div>

</body>
</html>

