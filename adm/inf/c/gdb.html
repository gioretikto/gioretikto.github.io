<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="gdb"/>
	<title>gdb</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>gdb</h1>

<p>The first step in using GDB (or most any other debugging tool) is to compile the code with <i>debugging symbols</i> - extra information to help a debugging tool understand what the layout of the code and data in memory is - included in the binary. The <b>-g</b> option to GCC requests that it include this debugging information, but if you are using GDB in particular, you should use <b>-ggdb3</b>, which request the maximum amount of debug information (<i>e.g</i>., it will include information about preprocessor macro definitions) in a GDB-specific format. </p>

<p>Compile the program with flags -O0 -ggdb3.</p>

<pre>gcc -W -Wall -Werror -Wextra -pedantic -std=c99 -O0 -ggdb3  program.c</pre>

<p>then run it under gdb</p>

<pre>gdb a.out</pre>

<p>If the program block the PC, try Ctrl+Alt+F1 (or other F-key), log in, killall -9 a.out, Ctrl+Alt+F1 (or whatever screen your desktop is).</p>

<p>To run GDB with arguments in the terminal, use the --args parameter.</p>

<pre>gdb --args executablename arg1 arg2 arg3</pre>

<p>Places break point in the C program, where you suspect errors (for example indicated in valgrind). While executing the program, the debugger will stop at the break point, and gives you the prompt to debug.</p>

<p>So before starting up the program, let us place the following break point in our program.</p>

<pre>b 90</pre>

<p>or</p>

<pre>break 90</pre>

<p>Per selezionare un file particolare del progetto</p>

<pre>break gtk_engine.c:188</pre>

<h2>Step 4. Execute the C program in gdb debugger</h2>

<pre>run [args]</pre>

<p>For example with</p>

<pre>run matrix 3</pre>

<p>You can start running the program using the run command in the gdb debugger. You can also give command line arguments to the program via run args. The example program we used here does not requires any command line arguments so let us give run, and start the program execution.</p>

<h2>Step 5. Printing the variable values inside gdb debugger</h2>

<p>The display command enables automatic displaying of certain expressions each time GDB stops at a breakpoint or after a step.</p>

<pre>disp fp</pre>

<pre>disp buf</pre>

<p>To continue the execution type:</p>

<pre>next</pre>

<p>or just</p>

<pre>n</pre>

<h2>Running gdb with arguments</h2>

<pre>gdb --args ./a.out arg1 arg2 arg3</pre>

<h2>Step 6. Continue, stepping over and in â€“ gdb commands</h2>

<p>There are three kind of gdb operations you can choose when the program stops at a break point. They are continuing until the next break point, stepping in, or stepping over the next program lines.</p>

<ul>
	<li><p><b>c</b> or <i>continue</i>: Debugger will continue executing until the next break point.</p></li>
	<li><p><b>n</b> or <i>next</i>: Debugger will execute the next line as single instruction.</p></li>
	<li><p><b>s</b> or <i>step</i>: Same as next, but does not treats function as a single instruction, instead goes into the function and executes it line by line.</p></li>
</ul>

<h2>Backtrace</h2>

<p>Basically, the backtrace is trace of the calls that lead to the crash. You print it with</p>

<pre>bt</pre>

<p>Type</p>

<pre>up</pre>

<p>to inspect the calling stack frame and see what the variables looked like: (you can usually write things like print x in the console). likewise, down will move down the call stack if you need to as well.</p>

<section aria-label="End">
<a href="valgrind.html">&#171;Valgrind</a>
<a href="index.html">Index</a>
<a href="makefile.html">Makefile &#187;</a>
</section>

</article>

</body>
</html>
