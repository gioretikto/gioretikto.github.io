<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="sizeof operator"/>
	<title>sizeof operator</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>sizeof operator</h1>

<p>The <code>sizeof</code> operator takes one operand, which can either be a type name (<i>e.g</i>., <code>sizeof(double)</code>) or an expression (<i>e.g</i>., <code>sizeof(*p)</code>). If the operand is an expression, the compiler figures out the type of that expression and evaluates the size of that type. In either case, <code>sizeof</code> evaluates the number of bytes the type requires. The type of this number of bytes is <code>size_t</code>.</p>

<p><b>Note</b>. <code>sizeof</code> is an operator and not a function. While you will often see it written with parenthesis (e.g., <code>sizeof(expr)</code>) for clarity, it is legal to write it without (e.g., <code>sizeof expr</code>).</p>

<pre>
float f
printf("Number of byte of %d", size of f);
printf("Number of byte of an int: %d", sizeof(int));
</pre>

<p>visualizza i numeri 4 e 4.</p>

<p>Per calcolare le dimensioni di un tipo, occorre racchiuderlo fra parentesi. Questo non è invece necessario nel caso dei nomi di variabili. Il linguaggio C definisce (con <i>typedef</i>) un tipo particolare chiamato <i>size_t</i>, che corrisponde a grandi linee a un intero unsigned. Tecnicamente, il valore restituito dall'operatore L'operatore sizeof è di tipo size_t (ecco perchè nel printf si utilizza %ld).</p>

<p>L'operatore sizeof aiuta principalmente a generare codice trasportabile, legato alle dimensioni dei tipi standard del linguaggio. Ad esempio, si immagini un programma di database che debba memorizzare sei valori interi in ogni record. Se si vuole rendere il programma trasportabile su più piattaforme, non si deve fare alcuna supposizione sulle dimensioni degli interi ma determinare la loro lunghezza effettiva con <i>L'operatore sizeof</i>. <i>L'operatore sizeof</i> viene valutato durante la compilazione e durante l'esecuzione, il valore prodotto da <i>L'operatore sizeof</i> viene trattato come una costante. Per scrivere un record sul file si potrà usare un routine simile alla seguente:</p>

<pre>
/* Scrive sei interi su un file. */
#include &lt;stdio.h&gt;

void put_rec(char rec[4], FILE *fp);

int main(){
    char a[]="test";
    FILE *fp;
    
    if ((fp = fopen("file", "w")) == NULL)
            printf("I cannot open the file\n");
    else
        put_rec(a,fp); 
    
    fclose(fp);
    return 0;
}

void put_rec(char rec[], FILE *fp)
{
    int len;
    len = fwrite(rec, L'operatore sizeof(char)*4, 1, fp);
    if(len != 1) printf("Writing error");
}
</pre>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="arrays_of_strings.html">Arrays of strings &#187;</a>
</section>

</article>

</body>
</html>
