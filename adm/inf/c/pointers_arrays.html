<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Pointers and arrays"/>
    <title>Pointers and arrays</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.html">Home</a></li>
        <li><a class="navbar" href="index.html">Index</a></li>
    </ul>
</nav>

<div class="content">

<h1>Pointers and arrays</h1>

<p>In C, there is a strong relationship between pointers and arrays, strong enough that pointers and arrays should be discussed simultaneously. Any operation that can be achieved by array
subscripting can also be done with pointers. The pointer version will in general be faster but, at least to the uninitiated, somewhat harder to understand. The declaration</p>

<pre>int a[10];</pre>

<p>defines an array of size 10, that is, a block of 10 consecutive objects named <i>a</i>[0], <i>a</i>[1] , ..., <i>a</i>[9] .</p>

<table class="centertable">
<tr><th>a:</th> <td>a[0]</td> <td>a[1]</td> <td>a[2]</td> <td>a[3]</td> <td>...</td> <td>a[9]</td></tr>
</table>

<p>La differenza principale:</p>

<ul>
	<li><p><b>An array has a static address, you cannot change it</b></p></li>
</ul>

<p>The notation <i>a</i>[i] refers to the <i>i</i> -th element of the array. If <i>pa</i> is a pointer to an integer, declared as</p>

<pre>int *pa;</pre>

<p>then the assignment</p>

<pre>pa = &a[0];</pre>

<p>sets <i>pa</i> to point to element zero of <i>a</i>; that is, <i>pa</i> contains the address of <i>a</i>[0].</p>

<pre>int *pa;</pre>

<p>Now the assignment</p>

<pre>x = *pa;</pre>

<p>will copy the contents of <i>a</i>[0] into <i>x</i>.</p>

<p>If <i>pa</i> points to a particular element of an array, then by definition <i>pa</i> + 1 points to the next element, pa+i points i elements after <i>pa</i> , and <i>pa - i</i> points <i>i</i> elements before. Thus, if <i>pa</i> points to <i>a</i>[0].</p>

<pre>*(pa+1)</pre>

<p>or</p>

<pre>pa[1]</pre>

<p>refers to the contents of a[1] , pa+i is the address of a[i] , and *(pa+i) is the contents of a[i].</p>

<table class="centertable">
<tr><th></th> <th>pa</th> <th>pa + 1</th> <th>pa + 2</th> <th>..</th> <th>pa + 9</th></tr>
<tr> <td></td> <td>↓</td> <td>↓</td> <td>↓</td> <td>...</td> <td>↓</td> </tr>
<tr><th>a:</th> <td>a[0]</td> <td>a[1]</td> <td>a[2]</td> <td>...</td> <td>a[9]</td></tr>
</table>

These remarks are true regardless of the type or size of the variables in the array <i>a</i>. The meaning of "adding 1 to a pointer," and by extension, all pointer arithmetic, is that <i>pa</i> + 1 points to the next object, and pa+i points to the i -th object beyond <i>pa</i>.</p>

<p>The correspondence between indexing and pointer arithmetic is very close. By definition, the value of a variable or expression of type array is the address of element zero of the array. Thus after the assignment</p>

<pre>pa = &amp;a[0]</pre>

<p><i>pa</i> and <i>a</i> have identical values. Since the name of an array is a synonym for the location of the initial element, the assignment <i>pa</i> = &amp;[0] can also be written as</p> 

<pre>pa = a</pre>

<h2>Relation between pointers and Arrays</h2>

<p>Rather more surprising, at first sight, is the fact that a reference to <i>a</i>[i] can also be written as *(a+i) . In evaluating a[i] , C converts it to *(<i>a+i</i>) immediately; the two forms are equivalent. Applying the operator &amp; to both parts of this equivalence, it follows that &a[i] and a+i are also identical: a+i is the address of the <i>i</i>-th element beyond <i>a</i>. As the other side of this coin, if <i>pa</i> is a pointer, expressions might use it with a subscript; <i>pa</i>[<i>i</i>] is identical to *(<i>pa+i</i>). In short, an array-and-index expression is equivalent to one written as a pointer and offset.</p>

<p>There is one difference between an array name and a pointer that must be kept in mind. A pointer is a variable, so pa=a and pa++ are legal. But an array name is not a variable;
constructions like <i>a = pa</i> and <i>a</i>++ are illegal.</p>

<p>An <code>int array x[]</code> with six items defined by <code>int x[6]</code>; is this represented by the C/C++ compiler as <code>int *x </code> a <b>constant pointer</b> (meaning that the pointer cannot be reset) and a statically alocated memory segment to accommodate six virtual data containers of the data type <code>int</code>. C/C++ compilers translate array indexing expressions like <code>x[i]</code> into indirection expressions like <code>*(x+1)</code>. Moreover, pointers can be "indexed": if <code>p</code> is any pointer (except void*), then the expression <code>p[i]</code> make sense when translated by the compiler to <code>*(p+1)</code> and so the program can be perfeclty well compiled and executes. <b>As we can see, arrays are treated as constant pointers, and the indexing mechanism in nothing but the dereferencing of these pointers</b>. In fact, a static array is nothing but a constant pointer that points to a properly (statically) allocated memory segment.</p>

<p>When an array name is passed to a function, what is passed is the location of the initial element. Within the called function, this argument is a local variable, and so an array name
parameter is a pointer, that is, a variable containing an address. We can use this fact to write another version of strlen , which computes the length of a string.

<pre>
/* strlen: return length of string s */
int strlen(char *s)
{
	int n;
	for (n = 0; *s != '\0', s++)
	n++;
	return n;
}
</pre>

<p>Since <i>s</i> is a pointer, incrementing it is perfectly legal; s++ has no effect on the character string in the function that called strlen , but merely increments strlen's private copy of the pointer. That means that calls like</p>

<pre>
strlen("hello, world");		/* string constant */
strlen(array);				/* char array[100]; */
strlen(ptr);				/* char *ptr; */
</pre>

<p>all work.</p>

<p>As formal parameters in a function definition,</p>

<pre>char s[];</pre>

<p>and</p>

<pre>char *s;</pre>

<p>are equivalent; we prefer the latter because it says more explicitly that the variable is a pointer. When an array name is passed to a function, the function can at its convenience
believe that it has been handed either an array or a pointer, and manipulate it accordingly. It can even use both notations if it seems appropriate and clear.</p>

<p>It is possible to pass part of an array to a function, by passing a pointer to the beginning of the subarray. For example, if <i>a</i> is an array,</p>

<pre>f(&a[2])</pre>

<p>and</p>

<pre>f(a+2)</pre>

<p>both pass to the function <i>f</i> the address of the subarray that starts at <i>a</i>[2] . Within <i>f</i>, the parameter declaration can read or</p>

<pre>f(int arr[]) { ... }</pre>

<p>or</p>

<pre>f(int *arr) { ... }</pre>

<p>So as far as <i>f</i> is concerned, the fact that the parameter refers to part of a larger array is of no consequence.</p>

<p>If one is sure that the elements exist, it is also possible to index backwards in an array; <i>p</i>[-1], <i>p</i>[-2] , and so on are syntactically legal, and refer to the elements that immediately precede <i>p</i>[0]. Of course, it is illegal to refer to objects that are not within the array bounds.</p>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
