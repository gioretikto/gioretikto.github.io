<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="The Valgrind Quick Start Guide"/>
	<title>The Valgrind Quick Start Guide</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<div class="content">

<h1>The Valgrind Quick Start Guide</h1>

<p>The <b>Valgrind</b> tool suite provides a number of debugging and profiling tools that help you make your programs faster and more correct. The most popular of these tools is called <b>Memcheck</b>. It can detect many memory-related errors that are common in C and C++ programs and that can lead to crashes and unpredictable behaviour.</p>

<p>The rest of this guide gives the minimum information you need to start detecting memory errors in your program with Memcheck. For full documentation of Memcheck and the other tools, please read the User Manual.</p>

<h2>Preparing your program</h2>
<p>Compile your program with -g to include debugging information so that Memcheck's error messages include exact line numbers. Using -O0 is also a good idea, if you can tolerate the slowdown. With -O1 line numbers in error messages can be inaccurate, although generally speaking running Memcheck on code compiled at -O1 works fairly well, and the speed improvement compared to running -O0 is quite significant. Use of -O2 and above is not recommended as Memcheck occasionally reports uninitialised-value errors which don't really exist.</p>

<h2>Running your program under Memcheck</h2>

<p>If you normally run your program like this:</p>

<pre>myprog arg1 arg2</pre>

<p>Use this command line:</p>

<pre>valgrind --leak-check=full --show-leak-kinds=all myprog arg1 arg2</pre>

<p>Memcheck is the default tool. The --leak-check option turns on the detailed memory leak detector.</p>

<p>Your program will run much slower (eg. 20 to 30 times) than normal, and use a lot more memory.
 Memcheck will issue messages about memory errors and leaks that it detects.</p>

<h2>Interpreting Memcheck's output</h2>

<p>Here's an example C program, in a file called a.c, with a memory error and a memory leak.</p>

<pre>
  #include &lt;stdlib.h&gt;

  void f(void)
  {
     int* x = malloc(10 * sizeof(int));
     x[10] = 0;        // problem 1: heap block overrun
  }                    // problem 2: memory leak -- x not freed

  int main(void)
  {
     f();
     return 0;
  }
</pre>

<p>Most error messages look like the following, which describes problem 1, the heap block overrun:</p>

<pre>
  ==19182== Invalid write of size 4
  ==19182==    at 0x804838F: f (example.c:6)
  ==19182==    by 0x80483AB: main (example.c:11)
  ==19182==  Address 0x1BA45050 is 0 bytes after a block of size 40 alloc'd
  ==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
  ==19182==    by 0x8048385: f (example.c:5)
  ==19182==    by 0x80483AB: main (example.c:11)
</pre>

<p>Things to notice:</p>

<ul>
    <li><p>There is a lot of information in each error message; read it carefully.</p></li>

    <li><p>The 19182 is the process ID; it's usually unimportant.</p></li>

    <li><p>The first line ("Invalid write...") tells you what kind of error it is. Here, the program wrote to some memory it
	 should not have due to a heap block overrun.</p></li>

    <li><p>Below the first line is a stack trace telling you where the problem occurred. Stack traces can get quite large,
 and be confusing, especially if you are using the C++ STL. Reading them from the bottom up can help. If the stack trace is not big
 enough, use the --num-callers option to make it bigger.</p></li>

    <li><p>The code addresses (eg. 0x804838F) are usually unimportant, but occasionally crucial for tracking down weirder bugs.</p></li>

    <li><p>Some error messages have a second component which describes the memory address involved. This one shows that the written memory is just past
	 the end of a block allocated with malloc() on line 5 of example.c.</p></li>
</ul>

<p>It's worth fixing errors in the order they are reported, as later errors can be caused by earlier errors.
 Failing to do this is a common cause of difficulty with Memcheck.</p>

<p>Memory leak messages look like this:</p>

<pre>
  ==19182== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
  ==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
  ==19182==    by 0x8048385: f (a.c:5)
  ==19182==    by 0x80483AB: main (a.c:11)
</pre>

<p>The stack trace tells you where the leaked memory was allocated. Memcheck cannot tell you why the memory leaked, unfortunately.
 (Ignore the "vg_replace_malloc.c", that's an implementation detail.)</p>

<p>There are several kinds of leaks; the two most important categories are:</p>

<ul>
    <li><p>"definitely lost": your program is leaking memory -- fix it!</p></li>

    <li><p>"probably lost": your program is leaking memory, unless you're doing funny things with pointers
 (such as moving them to point to the middle of a heap block).</p></li>
</ul>

<p>Memcheck also reports uses of uninitialised values, most commonly with the message "Conditional jump or move depends on uninitialised value(s)". It can be difficult to determine the root cause of these errors. Try using the --track-origins=yes to get extra information. This makes Memcheck run slower,
 but the extra information you get often saves a lot of time figuring out where the uninitialised values are coming from.</p>
 
<p>Let's different tipology of erros reported by Valgrind:</p>

<h2>Invalid write</h2>

<p>First, let’s write a simple C program.</p>

<pre>
int main(void)
{
        char *str = malloc(sizeof(char) * 10);
        int i = 0;

        while (i &lt; 15) {
                str[i] = '\0';
                i = i + 1;
        }
        free(str);
        return (0);
}
</pre>

<p>Yes, this code is absolutely useless, but still, let’s compile it then run it with valgrind.</p>

<pre>
$ gcc main.c -g
$ valgrind ./a.out
==18332== Memcheck, a memory error detector
==18332== Copyright (C) 2002-2017, and GNU GPL\'d, by Julian Seward et al.
==18332== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==18332== Command: ./a.out
==18332==
==18332== Invalid write of size 1
==18332==    at 0x400553: main (test.c:7)
==18332==  Address 0x521004a is 0 bytes after a block of size 10 alloc\'d
==18332==    at 0x4C2EB6B: malloc (vg_replace_malloc.c:299)
==18332==    by 0x400538: main (test.c:3)
==18332==
==18332==
==18332== HEAP SUMMARY:
==18332==     in use at exit: 0 bytes in 0 blocks
==18332==   total heap usage: 1 allocs, 1 frees, 10 bytes allocated
==18332==
==18332== All heap blocks were free'd -- no leaks are possible
==18332==
==18332== For counts of detected and suppressed errors, rerun with: -v
==18332== ERROR SUMMARY: 5 errors from 1 contexts (suppressed: 0 from 0)
</pre>

<p>So, what happened ? Well, Valgrind detected an invalid write error in our program. But what does it mean ?</p>

<p>“Invalid write” means that our program tries to write data in a memory zone where it shouldn’t.</p>

<p>But Valgrind tells you way more than that. It first tells you the size of the written data, which is 1 bytes, and corresponds to the size of a character. Then the line at 0x400553: main (test.c:7) tells you at which line your error occured. Line 7, which corresponds to str[i] = '\0'.</p>

<p>At the line Address 0x521004a is 0 bytes after a block of size 10 alloc\'d, it also tells you that the invalid adress is located right after a block of ten bytes allocated. What this means is that a 10 bytes (so probably 10 characters) long memory zone was allocated, but we tried to write an eleventh byte.</p>

<h2>Invalid read</h2>

<p>An Invalid read means that the memory location that the process was trying to read is outside of the memory addresses that are available to the process. size 8 means that the process was trying to read 8 bytes. On 64-bit platforms this could be a pointer, but also for example a long int.</p>

<pre>
==18500== Invalid read of size 8
==18500==    at 0xC5FB7F1: zim_MongoCursor_info (cursor.c:866)
==18500==    by 0x9AF93F: execute_internal (zend_execute.c:1480)
==18500==    by 0xBF1B8FD: xdebug_execute_internal (xdebug.c:1565)
==18500==    by 0x9B0715: zend_do_fcall_common_helper_SPEC (zend_vm_execute.h:645)
==18500==    by 0x9B0D88: ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER (zend_vm_execute.h:756)
==18500==    by 0x9AFCAA: execute (zend_vm_execute.h:410)
==18500==    by 0xBF1B47C: xdebug_execute (xdebug.c:1453)
==18500==    by 0x976CC6: zend_execute_scripts (zend.c:1315)
==18500==    by 0x8F3340: php_execute_script (main.c:2502)
==18500==    by 0xA172B9: do_cli (php_cli.c:989)
==18500==    by 0xA1825E: main (php_cli.c:1365)
==18500==  Address 0x38 is not stack'd, malloc'd or (recently) free'd
</pre>

<p>The last line of the error report says Address 0x38 is not stack'd, malloc'd or (recently) free'd, which means that the address that the process was trying to read 8 bytes from starts at 0x38. The line also says that the address is unavailable through stack space, heap space (malloc), or that it was recently a valid memory location.</p>

<p>A very low address, such as 0x38 (56 in decimal), combined with size 8 often indicates that you tried to dereference an element of a struct which was pointed to by a NULL pointer.</p>

<h2>Suppression files</h2>

<p>GLib and other libraries often make one-off allocations that are meant to exist until the end of the lifetime of your application. These are not leaks, but Valgrind will mark them as such. In order to avoid cluttering your reports, you can use “suppression files”, to tell Valgrind to eliminate known one-off allocations. GLib and GTK provide suppression files that you can use.</p>

<p>Assuming your copy of GLib and GTK are installed under /usr, the Valgrind suppression files are located here:</p>

<pre>/usr/share/glib-2.0/valgrind/glib.supp 
    /usr/share/gtk-4.0/valgrind/gtk.supp</pre>

<p>You can use them with the --<b>suppressions</b> argument for the memcheck tool, e.g.:</p>

<pre>valgrind --leak-check=full --show-leak-kinds=all --suppressions=gtk.supp --suppressions=glib.supp ./litos</pre>

<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
