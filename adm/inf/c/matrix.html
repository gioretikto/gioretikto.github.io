<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="Calcolo del determinante di una matrice"/>
    <title>Calcolo del determinante di una matric</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.php">Home</a></li>
        <li><a class="navbar" href="../../documentation.html">Documentation</a></li>
    </ul>
</nav>
      
<div class="content">

<h1>Calcolo del determinante matrice</h1>

<p>Il seguente legge in input una matrice quadrata da un file passata come aromento del tipo:</p>

<pre>
2 4 -5
4 0 -3
-5 -3 7
</pre>

<p>e ne calcola il determinante; compilare con: <i>gcc matr.c -Wall -lm</i></p>


<pre>
<code>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <string.h>

#define MAXNOP 50 /*Max number of operations allowed */
 
struct m{
    size_t row;
    size_t col;
    double *data;
};

struct m add(struct m *A, struct m *B, double n);
struct m multiply(struct m *A, struct m *B);
void f(double x);
void print_matrix(struct m *A);
void read_file(int maxc, FILE *fp);
void transpose(struct m *A);
double determinant(size_t n, struct m *A);
void scalar_product(double scalar, struct m *B);
void inverse(size_t n, struct m *A);
void calculate(struct m *matrix, int nop, int id, char *op);

int main(int argc, char *argv[]){
    
    FILE *file = argc > 1 ? fopen(argv[1], "rb") : stdin;
   
    /*define max dimension of a matrix */
    int maxc = argc>2?atoi(argv[2])*atoi(argv[2]):100;
    
    read_file(maxc, file);       
 
    return 0;
}

void read_file(int maxc, FILE *fp)
{
    struct m *matrix;
    int id = 0; /* id of a matrix */
    size_t ncol,nrow; /* No of columns of a matrix*/
    ncol = nrow = 0;
    int nop = 0; /*No of operators*/
    int off = 0;
    int i;
    int n;
    double *d;
    char buf[maxc]; /*to store each lines of file */
    char *p = buf;
    char op[MAXNOP];
    
    for (i=0; i < MAXNOP; i++)
            op[i]='?';    
   
    if (!(matrix = malloc(maxc*sizeof *matrix))) {
        perror ("malloc-matrix");
            exit(1);
    }
    
    /*Read file line by line */
    while (fgets (buf, maxc, fp)){
        
        if (nrow == 0){
            /* allocate/validate max no. of matrix */
            d = matrix[id].data = malloc(sizeof(double) * 10*10);
        }
        
        if (strcmp(buf, "^-1\n") == 0){
                op[nop++] = 'i'; /* matrix inverse operation */
                continue;
        }
            
        else if (strcmp(buf, "det\n") == 0){
                op[nop++] = 'd'; /* determinant operation */
                continue;
        }
        
        /*check if line contains operator */
        else if ( (!isdigit(*buf) && buf[1] =='\n'))
        {      
            op[nop++] = *buf;
            matrix[id].col = ncol;
            matrix[id].row = nrow;
            nrow = ncol = 0;
            id++;
            continue;
        }
        
        else /* read integers in a line into d */
        {
            while (sscanf (p + off, "%lf%n", d, &n) == 1) {
                d++;
                if(nrow == 0)
                    ncol++;
                off += n;
            }
            nrow++;
            off = 0;
        }
    } /*end of while fgets cycle */
       
    /*Assign last matrix No of columns and rows */
    matrix[id].col = ncol;
    matrix[id].row = nrow;
    
    /*Printing the matrices and operations */
    for(i=0; i <= id; i++){
     
        if(op[i] == 'd'){
            printf("det\n");
            print_matrix(&matrix[i]);
        }
        
        else if (op[i] == '*' || op[i] == '-' || op[i] =='+')
        {
            print_matrix(&matrix[i]);
            printf("%c\n", op[i]);            
        }
        
        else if (op[i] == 't' || op[i] =='T'){            
             print_matrix(&matrix[i+1]);
             printf("%c\n", op[i]);
        }
        
        else if (op[i] == 'i'){
            print_matrix(&matrix[i+1]);
            printf("^-1\n"); /* matrix inverse operation */
        }
        
        else if(op[i] == '?'){
             print_matrix(&matrix[i]);
        }        
    }
    
    calculate(matrix, nop, id, op);
}

void calculate(struct m *matrix, int nop, int id, char *op)
{    
    int i;
    int j;
    
    for(i=0; i < nop;){
        j=0;
        /*Transpose the matrices */
        if(op[i] == 't' || op[i] == 'T'){
            transpose(&matrix[0]);
            while(op[j] !='?'){
                op[j] = op[j+1];
                j++;
            }
            continue;
        }
                    
        else if(op[i] == 'd'){
            matrix[i].data[0] = determinant(matrix[i].row, &matrix[i]);
            matrix[i].row = 1;
            matrix[i].col = 1;
            while(op[j] !='?'){
                op[j] = op[j+1];
                j++;
            }
            continue;
        }
        
        else if(op[i] == 'i'){
            
            if(matrix[0].row != matrix[0].col)
                printf("Error: Not a square matrix\n");
            else{
                inverse(matrix[0].row, &matrix[0]);
                 while(op[j] !='?'){
                    op[j] = op[j+1];
                    j++;
                }
                continue;
            }
        }
        i++;
    }
    
    for(i=0; i <= nop; i+=2)
    {        
        if (op[i] == '+' && op[i+1] == '?'){
            matrix[i+1] = add(&matrix[i],&matrix[i+1],+1);
            break;
         }
          
         else if (op[i] == '-' && op[i+1] == '?'){
            matrix[i+1] = add(&matrix[i],&matrix[i+1],-1);
            break;
         }
         
         else if(op[i] == '*' && op[i+1] == '?'){
             if (matrix[i].row == 1 && matrix[i].col == 1)
                 scalar_product(matrix[i].data[0], &matrix[i+1]); //Multiplication of Scalar per matrix
             else{                 
                 matrix[i+1] = multiply(&matrix[i],&matrix[i+1]);
                 matrix[i+2] = multiply(&matrix[i+1],&matrix[i+2]);
             }
             break;
         }
       
         else if(op[i] == '*' && op[i+1] == '+'){
             if (matrix[i].row == 1 && matrix[i].col == 1){
                 scalar_product(matrix[i].data[0],&matrix[i+1]); //Multiplication of Scalar per matrix
                 matrix[i+2] = add(&matrix[i+1],&matrix[i+2],+1);
             }
             else{                 
                 matrix[i+1] = multiply(&matrix[i],&matrix[i+1]);
                 matrix[i+2] = add(&matrix[i+1],&matrix[i+2],+1);
             }
        }
        
            else if(op[i] == '*' && op[i+1] == '-'){
             if (matrix[i].row == 1 && matrix[i].col == 1){
                 scalar_product(matrix[i].data[0],&matrix[i+1]); //Multiplication of Scalar per matrix
                 matrix[i+2] = add(&matrix[i+1],&matrix[i+2],-1);
             }
             else{                 
                 matrix[i+1] = multiply(&matrix[i],&matrix[i+1]);
                 matrix[i+2] = add(&matrix[i+1],&matrix[i+2],-1);
             }
        }
            
         else if (op[i] == '+' && op[i+1] == '*'){
             if (matrix[i+1].row == 1 && matrix[i+1].col == 1){
                 scalar_product(matrix[i+1].data[0],&matrix[i+2]); //Multiplication of Scalar per matrix
                 matrix[i+2] = add(&matrix[i],&matrix[i+2],+1);
             }
             else{                 
                 matrix[i+1] = multiply(&matrix[i],&matrix[i+1]);
                 matrix[i+2] = add(&matrix[i+1],&matrix[i+2],+1);
             }
         }
         
         else if (op[i] == '-' && op[i+1] == '*'){
             if (matrix[i+1].row == 1 && matrix[i+1].col == 1){
                 scalar_product(matrix[i+1].data[0],&matrix[i+2]); //Multiplication of Scalar per matrix
                 matrix[i+2] = add(&matrix[i],&matrix[i+2],-1);
             }
             else{                 
                 matrix[i+1] = multiply(&matrix[i],&matrix[i+1]);
                 matrix[i+2] = add(&matrix[i+1],&matrix[i+2],-1);
             }
         }
         
         else if (op[i] == '-' && op[i+1] == '*'){
            matrix[i+1] = multiply(&matrix[i],&matrix[i+2]);
            matrix[i+2] = add(&matrix[i],&matrix[i+1],-1);
         }
    }
    
    printf("=\n");
    print_matrix(&matrix[id]); /*Print the result */
    free(matrix);
}

struct m multiply(struct m *A, struct m *B) 
{ 
    size_t i, j, k;
    struct m C;
    C.data = malloc(sizeof(double) * A->row * B->col);
 
    C.row = A->row;
    C.col = B->col;
 
    for (i=0; i< C.row; i++)
        for (j=0; j < C.col; j++)
            C.data[i * C.col + j] = 0;
 
    // Multiplying matrix A and B and storing in C.
    for(i = 0; i < A->row; ++i)
        for(j = 0; j < B->col; ++j)
            for(k=0; k < A->col; ++k)
              C.data[i * C.col + j] += A->data[i * A->col + k] * B->data[k * B->col + j];
            
    return C;
}

struct m add(struct m *A, struct m *B, double n) 
{ 
    if ( (A->row != B->row) || (A->col != B->col) ){
        printf("Error: You can't sum up matrix of different dimension\n");
        exit(1);
    }    
    
    size_t i, j;
    
    struct m C;
    C.data = malloc(sizeof(double) * A->row * B->col);
    C.row = A->row;
    C.col = A->col;
    
    for (i=0; i< C.row; i++)
      for (j=0; j < C.col; j++)
        C.data[i * C.col + j] = A->data[i * A->col + j] + n *B->data[i * B->col + j];
        
    return C;
}

void f(double x)
{
    double i,f= modf(x,&i);
    
    if(f<.00001)
        printf("%.f ",i);
    
    else printf("%f ",x);
}

/*printing a Matrix*/

void print_matrix(struct m *A){
    
     size_t i,j;

     double *tmp = A->data;
     
     for(i=0; i < A->row; i++){
        for(j=0; j < A->col; j++){
                f(*(tmp++));
        }
        putchar('\n');
    }
}

void scalar_product(double scalar, struct m *B)
{
     size_t i,j;
     
     for(i=0; i < B->row; i++)
        for(j=0; j < B->col; j++)
           B->data[i * B->col + j] = scalar * B->data[i * B->col + j];
}

void transpose(struct m *A)
{ 
    struct m C;
    C.data = malloc(sizeof(double) * A->row * A->col);
 
    C.row = A->col;
    C.col = A->row;

    size_t i, j; 
    for (i = 0; i < C.row; i++) 
        for (j = 0; j < C.col; j++) 
            C.data[i * C.col + j] = A->data[j * A->col  + i];
    *A = C;
}


double determinant(size_t n, struct m *A)
{                                    
    size_t i,j,i_count,j_count, count=0;
    
    double det = 0;
 
    if(n < 1)
    {
        printf("Error\n");
        exit(1);
    }
    
    else if(n==1) return A->data[0];
    
    else if(n==2) return (A->data[0]* A->data[1 * A->col + 1] - A->data[0 + 1] * A->data[1*A->col + 0]);    
    
    else{
        struct m C;
            
        C.row = A->row-1;
        C.col = A->col-1;
            
        C.data = malloc(sizeof(double) * (A->row-1) * (A->col-1));
        
        for(count=0; count < n; count++)
        {
            //Creating array of Minors
            i_count = 0;
            for(i = 1; i < n; i++)
            {
                j_count=0;
                for(j = 0; j < n; j++)
                {
                    if(j == count)
                        continue; // don't copy the minor column element
                    C.data[i_count * C.col + j_count] = A->data[i * A->col + j];
                    j_count++;
                }
                i_count++;
            }
            det += pow(-1, count) * A->data[count] * determinant(n-1,&C);//Recursive call
        }
        free(C.data);
        return det;
    }
}

/*Calculate the inverse of a matrix */

void inverse(size_t n, struct m *A) 
{
    double det;
    if( (det = determinant(n, A)) == 0 ){
        printf("The matrix is singular\n");
        exit(1);
    }
    
    size_t i,j,i_count,j_count, count=0;

    struct m C; /*The Adjoint matrix */
    C.data = malloc(sizeof(double) * n * n);

    C.row = n;
    C.col = n; 
    double Rdata[(n-1)*(n-1)];        // remaining data values
    struct m R = { n-1, n-1, Rdata }; // matrix structure for them
    for (count = 0; count < n*n; count++) // Create n*n Matrix of Minors
    {
        size_t row = count/n, col = count%n;
        for (i_count = i = 0; i < n; i++)
            if (i != row)                   // don't copy the current row
            {
                for (j_count = j = 0; j < n; j++)
                    if (j != col)           // don't copy the current column
                        Rdata[i_count*R.col+j_count++] = A->data[i*A->col+j];
                i_count++;
            }
        // transpose by swapping row and column
        C.data[col*C.col+row] = pow(-1, row&1 ^ col&1) * determinant(n-1, &R) / det;
    }
    *A=C;
}
</pre>

<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
