<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Two-Dimensional Arrays">
	<title>Two-Dimensional Arrays</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<div class="content">
  
<h1>Two-Dimensional Arrays</h1>

<p>Two-dimensional arrays use rows and columns to identify array elements.</p>

<pre>int arr[3][4] = {	{1,2,3,4},
			{5,6,7,8},
			{9,10,11,12}
					};</pre>

<table>

<tr><th></th> <th>Col 1</th> <th>Col 2</th> <th>Col 3</th> <th>Col 4</th></tr>

<tr><th>Row 2</th> <td>1</td> <td>2</td> <td>3</td> <td>4</td></tr>

<tr><th>Row 3</th> <td>5</td> <td>6</td> <td>7</td> <td>8</td></tr>

<tr><th>Row 3</th> <td>9</td> <td>10</td> <td>11</td> <td>12</td></tr>

</table>

<p>Since memory in a computer is organized linearly it is not possible to store the 2D array in rows and columns. The concept of rows and columns is only theoretical, actually, a 2-D array is stored in row-major order i.e rows are placed next to each other. The following figure shows how the above 2-D array will be stored in memory.</p>

<table>

<tr><th>arr[0][0]</th> <th>arr[0][1]</th> <th>arr[0][2]</th><th>arr[0][3]</th> <th>arr[1][0]</th> <th>arr[1][1]</th> <th>arr[1][2]</th> <th>arr[1][3]</th><th>arr[2][0]</th> <th>arr[2][1]</th> <th>arr[2][2]</th>  <th>arr[2][3]</th></tr>

<tr><td>6000</th> <td>6004</td> <td>6008</td> <td>6012</td> <td>6016</td> <td>6020</td> <td>6024</td> <td>6028</td> <td>6032</td> <td>6036</td> <td>6040</td> <td>6044</td></tr>

<tr><td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> <td>9</td> <td>10</td> <td>11</td> <td>12</td> </tr>

<tr><th colspan="4">Row 1</th> <th colspan="4">Row 2</th> <th colspan="4">Row 3</th> </tr>

</table>

<p>Here is the most important concept you need to remember about a multi-dimensional array.</p>

<blockquote>
A 2-D array is actually a 1-D array in which each element is itself a 1-D array. So <i>arr</i> is an array of 3 elements where each element is a 1-D array of 4 integers.
</blockquote>

<p>In the previous chapter, we have already discussed that the name of a 1-D array is a constant pointer to the 0th element. In the case, of a 2-D array, 0th element is a 1-D array. Hence in the above example, the type or base type of <i>arr</i> is a pointer to an array of 4 integers. Since pointer arithmetic is performed relative to the base size of the pointer. In the case of <i>arr</i>, if <i>arr</i> points to address 6000 then <i>arr</i> + 1 points to address 6016 (i.e 6000 + 4*4). </p>

<p>So here <i>arr</i> in the example is an array of 3 elements where each element is a 1-D array of 4 integers. We know that the name of an array is a constant pointer that points to 0th 1-D array and contains address 6000. Since arr is a ‘pointer to an array of 4 integers’, according to pointer arithmetic the expression <i>arr + 1</i> will represent the address 5016 and expression <i>arr + 2</i> will represent address 6032. </p>

<p>We know that the name of the array is a constant pointer that points to the 0th element of the array. In the case of a 2-D array, 0th element is a 1-D array. So the name of the array in case of a 2-D array represents a pointer to the 0th 1-D array. Therefore in this case arr is a pointer to an array of 4 elements. If the address of the 0th 1-D is 6000, then according to pointer arithmetic (arr + 1) will represent the address 6016, similarly (arr + 2) will represent the address 6032.</p>

<p>From the above discussion, we can conclude that:</p>

<p>arr points to 0th 1-D array.</p>
<p>(arr + 1) points to 1st 1-D array.</p>
<p>(arr + 2) points to 2nd 1-D array. </p>

<table>

<tr><th>arr ⟶</th> <td>1</td> <td>2</td> <td>3</td> <td>4</td></tr>

<tr><th>arr + 1 ⟶</th> <td>5</td> <td>6</td> <td>7</td> <td>8</td></tr>

<tr><th>arr + 2 ⟶</th> <td>9</td> <td>10</td> <td>11</td> <td>12</td></tr>

</table>

<p>We already discussed the relation between <a href="pointers_arrays.html">Pointers and Arrays</a>; The important point you need to remember about pointer to an array is this:</p>

<blockquote>Whenever a pointer to an array is dereferenced we get the address (or base address) of the array to which it points.</blockquote>

<p>So dereferencing <i>arr</i> we will get *arr, base type of *arr is (int*). Similarly, on dereferencing arr+1 we will get *(arr+1). In general, we can say that:</p>

<p>*(arr+i) points to the base address of the ith 1-D array.</p>

<p>Again it is important to note that type (arr + i) and *(arr+i) points to same address but their base types are completely different. The base type of (arr + i) is a pointer to an array of 4 integers, while the base type of *(arr + i) is a pointer to int or (int*).</p>

<p>So how you can use arr to access individual elements of a 2-D array? Since *(arr + i) points to the base address of every ith 1-D array and it is of base type pointer to int, by using pointer arithmetic we should we able to access elements of ith 1-D array Let's see how we can do this:</p>

<p>*(arr + i) points to the address of the 0th element of the 1-D array.</p>
<p>*(arr + i) + 1 points to the address of the 1st element of the 1-D array</p>
<p>*(arr + i) + 2 points to the address of the 2nd element of the 1-D array </p>

<p>Therefore, the following two statements are equivalent:</p>

<pre>
arr[i][j]
*(*(arr + i) + j)
</pre>

<p>A two-dimensional array is treated as an array of arrays. That is, when we access the array using only one subscript, we get a pointer to the corresponding row. This is demonstrated in the following code sequence where each row’s address and size is displayed:</p>

<pre>
    for (int i = 0; i &lt; 2; i++) {
        printf("&amp;matrix[%d]: %p  sizeof(matrix[%d]): %d\n", 
                i, &amp;matrix[i], i, sizeof(matrix[i]));
    }
</pre>

<p>The following output assumes the array is located at address 100. The size is 12 because each row has three elements of four bytes each:</p>

<pre>
&amp;matrix[0]: 100 sizeof(matrix[0]): 12
&amp;matrix[1]: 112 sizeof(matrix[1]): 12
</pre>

<p>In the section Pointers and Multidimensional Arrays, we will examine this behavior in more detail.</p>

<h2>Example reading a NxN matrix</h2>

<p>Suppose you need to read a file formatted thus:</p>

<pre>
56 154 59 365 98
98 54 69 365 52
-76 154 29 365 34
37 154 57 365 7
37 154 57 365 7
</pre>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {

    FILE *fp;
    char *filename;
    char *dim_arg;
    
    if (argc &lt; 3)
    {
        printf("Error\n");
        exit(1);
    }
    
  	else {
  		dim_arg = argv[1];
	  	filename = argv[2];
		fp = fopen(filename, "r");
		
		if (fp == NULL) {
		    fprintf(stderr, "Error: Cannot open file %s for reading\n", filename);
		    exit(1);
		}		
   }
   
   int dim = atoi(dim_arg);   
 
   int i, j, cell[dim][dim];
     
   for (i = 0; i &lt; dim; i++) {
       for (j = 0; j &lt; dim; j++) {
           if (fscanf(fp, "%d ", &cell[i][j]) != 1) {
               fprintf(stderr, "invalid input for cell[%d][%d]\n", i, j);
               fclose(fp);
               exit(1);
           }
       }
   }   
   
   fclose(fp);
   
   /*Print the matrix */
   
   for (i = 0; i &lt; dim ; i++)
   {
       for (j = 0; j &lt; dim ; j++)
       {
           printf("%d ", cell[i][j]);
       }
       printf("\n");
   }
   
   printf("\n");

   return 0;
}
</pre>

<p>The "%d" format is able to read also the the last item of a line "5\n".</p>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
