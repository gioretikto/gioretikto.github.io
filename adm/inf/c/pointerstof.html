<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="Pointers to functions"/>
    <title>Pointers to functions</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.php">Home</a></li>
        <li><a class="navbar" href="../../documentation.html">Documentation</a></li>
    </ul>
</nav>
      
<div class="content">

<h1>Pointers to functions</h1>

<p>In C, like normal data pointers (int *, char *, etc), we can have pointers to functions. Following is a simple example that shows declaration and function call using function pointer.</p>

<pre>
#include &lt;stdio.h&gt;

void <span class="function">fun</span>(int a)
{  
    <span class="function">printf</span>("Value of a is %d\n", a);
} 

int <span class="function">main</span>()
{ 
    void (*fun_ptr)(int) = &fun;
    (*fun_ptr)(<span class="number">10</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre>

<p>Output:</p>

<pre>Value of a is 10</pre>

<p>Why do we need an extra bracket around function pointers like fun_ptr in above example?
If we remove bracket, then the expression “void (*fun_ptr)(int)” becomes “void *fun_ptr(int)” which is declaration of a function that returns void pointer.</p>

<p>A function’s name can also be used to get functions’ address. For example, in the below program, we have removed address operator ‘&amp;’ in assignment. We have also changed function call by removing *, the program still works.</p>

<pre>
fun_ptr(10);  
</pre>

<h2>Array of function pointers</h2>

<p>Like normal pointers, we can have an array of function pointers. 
Function pointer can be used in place of switch case. For example, in below program, user is asked for a choice between 0 and 2 to do different tasks.</p>

<pre>
#include &lt;stdio.h&gt;

void add(int a, int b) 

{ 
    printf("Addition is %d\n", a+b); 

} 

void subtract(int a, int b) 

{ 
    printf("Subtraction is %d\n", a-b); 

} 

void multiply(int a, int b) 

{ 
    printf("Multiplication is %d\n", a*b); 
} 

int main() 

{ 
    void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; 

    unsigned int ch, a = 15, b = 10; 

    printf("Enter Choice: 0 for add, 1 for subtract and 2 "

            "for multiply\n"); 

    scanf("%d", &amp;ch); 

    if (ch > 2) return 0; 

    (*fun_ptr_arr[ch])(a, b); 

    return 0;
}
</pre>

<p>Output:</p>

<pre>
Enter Choice: 0 for add, 1 for subtract and 2 for multiply
2
Multiplication is 150</pre>

<p>In C, we can use function pointers to avoid code redundancy. For example a simple qsort() function can be used to sort arrays in ascending order or descending or by any other order in case of array of structures. Not only this, with function pointers and void pointers, it is possible to use qsort for any data type.</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int compare (const void * a, const void * b) 

{ 

  return ( *(int*)a - *(int*)b ); 

} 

int main () 

{ 

  int arr[] = {10, 5, 15, 12, 90, 80}; 

  int n = sizeof(arr)/sizeof(arr[0]), i; 

  qsort (arr, n, sizeof(int), compare); 

  for (i=0; i&lt;n; i++) 

     printf ("%d ", arr[i]); 

  return 0; 

}
</pre>

<p>Output:</p>

<pre>
5 10 12 15 80 90
</pre>

<p>Similar to qsort(), we can write our own functions that can be used for any data type and can do different tasks without code redundancy. Below is an example search function that can be used for any data type. In fact we can use this search function to find close elements (below a threshold) by writing a customized compare function.</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

bool compare (const void * a, const void * b) 

{ 

  return ( *(int*)a == *(int*)b ); 

} 

int search(void *arr, int arr_size, int ele_size, void *x, 

           bool compare (const void * , const void *)) 

{ 

    char *ptr = (char *)arr; 

    int i; 

    for (i=0; i&lt;arr_size; i++) 

        if (compare(ptr + i*ele_size, x)) 

           return i; 

    return -1; 

} 

int main() 

{ 

    int arr[] = {2, 5, 7, 90, 70}; 

    int n = sizeof(arr)/sizeof(arr[0]); 

    int x = 7; 

    printf ("Returned index is %d ", search(arr, n, sizeof(int), &amp;x, compare)); 

    return 0; 

} 
</pre>

<p>Output:</p>

<pre>Returned index is 2</pre>

<p>The above search function can be used for any data type by writing a separate customized compare(). </p>

<h2>Complicated Function Pointer example</h2>

<po>You will find a lot of complex function pointer examples around, lets see one such example and try to understand it.</p>

<pre>
void *(*foo) (int*);
</pre>

<p>It appears complex but it is very simple. In this case <code>(*foo)</code> is a pointer to the function, whose argument is of <code>int*</code> type and return type is void*.</p>


<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</div>

</body>
</html>
