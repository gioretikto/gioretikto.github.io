<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Pointers to function"/>
	<title>Pointers to function</title>
	<link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
	<ul>
		<li><a class="navbar" href="../../index.html">Home</a></li>
		<li><a class="navbar" href="index.html">Index</a></li>
	</ul>
</nav>

<article>

<h1>Pointers to function</h1>

<p>Un <i>puntatore a una funzione</i> contiene il suo indirizzo di memoria. In modo simile, il nome di una funzione è in realtà l'indirizzo di memoria dal quale inizia il codice che eseguirà il compito della funzione. Questo tipo di puntatori potrà essere passato e restituito dalle funzioni, memorizzato in vettori e assegnato ad altri puntatori a funzioni.</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
double (*fp[7])(double x);

int main()
{
	double x;
	int p;

	fp[0] = sin;
	fp[1] = cos;
	fp[2] = acos;
	fp[3] = asin;
	fp[4] = tan;
	fp[5] = atan;
	fp[6] = ceil;

	p = 4;

	x = fp[p] (1.5);

	printf("\nResult %lf", x);
	return 0;
}
</pre>

<p>Questo programma definisce un array di puntatori a funzioni (*fp[])( ) che vengono richiamate a seconda del valore della variabile di indicizzazione <i>p</i>. Questo programma potrebbe essere riscritto anche nel seguente modo:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
double (*fp[7])(double x);

int main()
{
	double x;
	int p;

	p = 4;

	switch(p)
	{

		case 0: x = sin(1.5);
			break;

		case 1: x = cos(1.5);
			break;

		case 2: x = acos(1.5);
			break;

		case 3: x = asin(1.5);
			break;

		case 4: x = tan(1.5);
			break;

		case 5: x = atan(1.5);
			break;

		case 6: x = ceil(1.5);
			break;
	}

	puts("\nResult %lf",x);
	return 0;
}
</pre>

<p>Il primo esempio, che usava puntatori a funzioni, produce un codice più compatto e viene eseguito più rapidamente del secondo.</p>

<p>Per fare un altro esempio mostrtiamo l'utilizzo di puntatori a funzioni per eseguire l'ordinatore di un vettore in senso ascendente e discendente.</p>

<pre>
#include &lt;stdio.h&gt;
#define SIZE 10

void bubble (int work[], const int size, int (*compare) (int a, int b));
void swap(int *element1ptr, int *element2ptr);
int ascending (int a, int b);	
int descending (int a, int b);

int main()
{
	int order;
	int counter;
	
	int a[SIZE] = {6,4,8,10,66,34,82,2,77,56};	/* Vettore da ordinare */
	
	printf("Enter 1 to sort in descending order,\n"
			"Enter 2 to sort in ascending order: ");
	
	scanf("%5d", &order);
	
	for (counter = 0; counter &lt; SIZE; counter++) {
		printf("%5d", a[counter]);
	}
		
	if (order == 1) {
		bubble(a, SIZE, ascending);
		printf("\nData iterms in ascending order\n");
	}
	
	else {
		bubble(a, SIZE, descending);
		printf("\nData iterms in descending order\n");
	}
	
	for (counter = 0; counter &lt; SIZE; counter++) {
		printf("%5d", a[counter]);
	}
	
	printf("\n");
	
	return 0;
}

void bubble (int work[], const int size, int (*compare) (int a, int b)) {

	int pass;
	int count;
	
	void swap(int *element1ptr, int *element2ptr);
	
	for (pass = 0; pass &lt; size ; pass++) {
	
		for (count = 0; count &lt; size - 1 ; count++) {
		
			if( (*compare) (work[count], work[count + 1])) {
			
				swap (&work[count], &work[count + 1]);
			}
	}
	
	}
}

/* scambia i valori nelle locazioni di memoria puntate da element1ptr e element2ptr */
void swap(int *element1ptr, int *element2ptr) {

	int hold = *element1ptr;
	*element1ptr = *element2ptr;
	*element2ptr = hold;
}

int ascending (int a, int b) {
	
	return b &lt; a;	/* Effettua uno scambio se b è minore di a */
}

int descending (int a, int b) {
	
	return b &gt; a; 	/* Effettua uno scambio se b è maggiore di a */
}
</pre>

<p>Nell'intestazione della funzione <code>bubble</code> appare il seguente parametro:</p>

<pre>int (*compare) (int a, int b)</pre>

<p>La funzione <code>bubble</code> riceve quindi un parametro (compare) che è un puntatore a una funzione che accetta due argomenti interi e che restituisce un risultato dello stesso tipo. Le parentesi intorno a *compare sono necessarie per raggruppare * con <i>compare</i> in modo da indicare che quest'ultimo è un puntatore. Se non avessimo incluso le parentesi, la dichiarazione sarebbe diventata:</p>

<pre>int *compare (int a, int b)</pre>

<p>che avrebbe indicato una funzione che riceve due parametri interi e restituisce un puntatore dello stesso tipo.</p>

<p>Il prototipo della funzione bubble si sarebbe potuto scrivere anche come</p>

<pre>int (*) (int , int )</pre>

<p>senza il nome del puntatore a funzione e i nomi dei parametri.</p>

<section aria-label="End">
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="continuity.html">Definizione limite per funzioni operanti tra spazi metrici o normati &#187;</a>
</section>

</article>

</body>
</html>
