<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="description" content="References"/>
    <title>References</title>
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
    <ul>
        <li><a class="navbar" href="../../index.php">Home</a></li>
        <li><a class="navbar" href="../../documentation.html">Documentation</a></li>
    </ul>
</nav>
      
<div class="content">

<h1>References</h1>

<p>A reference is an alias, or an alternative name, for a variable. You can think of a reference as a constant pointer that is always dereferenced. References are much like constants in that they must be initialized when declared and their value cannot be changed after that.To create a reference, you use the reference ( & ) operator. Donâ€™t confuse this operator with the address of operator. You will be able to tell which is which according to the current context. Here is the syntax for declaring a reference:</p>

<pre>data_type& reference_name;</pre>

<p>Here data_type is the type of variable that the reference is a reference to and reference_name is the name of the reference. To initialize a reference (as you must do when you declare it), you assign a variable of type data_type to the reference creation:</p>

<pre>data_type& reference_name = variable;</pre>

<p>Here is an example of how to create and initialize a reference:</p>

<pre>
int x;
int& rx = x;
</pre>

<p>The preceding code causes rx to be a reference to the variable <code>x</code>. Strangely enough, operators do not act on a reference. They act only on the variable referenced by the reference. For example, if you increment <code>rx</code> as</p>

<pre>rx++;</pre>

<p><code>x</code> is incremented by one. <code>rx</code> is just another name for <code>x</code>. You use references mainly as function
parameters and return types.


<h2>USING REFERENCES IN FUNCTION PARAMETERS</h2>

<p>You can legally make any function parameter a reference. This can be useful if you want to write a function that can change the argument passed to it. For example, you can write a function called decrement that has a reference parameter like this:</p>

<pre>
void decrement(int& x)
{
	x--;
}
</pre>

<p>You can then use this function as follows:</p>

<pre>
int a = 5;
decrement(a);
cout &lt;&lt; a;
</pre>


<p>Output:</p>
<pre>4</pre>

<p>Because <code>x</code> becomes a reference to a when decrement is called, decrementing <code>x</code> changes the value of <code>a</code>. As you can see, this looks much cleaner than using references to do the same thing.</p>

<h2>USING REFERENCES AS FUNCTION RETURN VALUES</h2>

<p>As you might suspect, you can return a reference to a variable in a function. However, the implications of doing so are not so obvious. Consider the following example. </p>

<pre>
#include &lt;iostream&gt;

class Point
{
	int X,Y;
	public:
		Point(int lX, int lY):X(lX),Y(lY) {}
		int& GetX() {return X;}
		int& GetY() {return Y;}
};

int main(void)
{
	using std::cout;
	Point p(5,3);
	p.GetX() = 3;
	p.GetY() = 5;
	cout &lt;&lt; p.GetX() &lt;&lt; p.GetY() << "\n";
	return 0;
}
</pre>

<p>Output:</p>

<pre>35</pre>

<p>Because <code>GetX()</code> and <code>GetY()</code> return references to the member variables <code>X</code> and <code>Y</code>, you can use
these function calls as lvalues (lvalues are values, or variables, that can be changed). Changing the value of these references changes only the values of the member variables, <code>X</code> and <code>Y</code> .</p>

<section>
<a href="system.html">&#171;Thermodynamic Systems</a>
<a href="index.html">Index</a>
<a href="hello_world.html">Hello World &#187;</a>
</section>

</div>

</body>
</html>
