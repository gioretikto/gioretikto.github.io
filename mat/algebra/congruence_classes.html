<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
 <meta name="description" content="Congruence classes"/>
 <title>Congruence classes</title>
 <link rel="stylesheet" type="text/css" href="../../style.css" media="screen">
</head>

<body>

<nav>
 <ul>
  <li><a class="navbar" href="../../index.html">Home</a></li>
  <li><a class="navbar" href="index.html">Algebra</a></li>
 </ul>
</nav>
  
<div class="content">

<h1>Congruence classes</h1>

<p>Congruence leads to the construction of the set ℤ<sub><i>n</i></sub> of all congruence classes of integers modulo <i>n</i>. This construction will serve as a model for many similar constructions in the rest of our study.</p>

<p>We saw in the last paragraph that when <i>a, b</i> ∈ ℤ with <i>a ≡ b</i> mod <i>n</i>, then <i>a</i> and <i>b</i> are congruent modulo <i>n</i> to the same nonnegative remainder <i>r &lt; n</i>. It will be convenient, therefore, to “lump together” into a single set integers which are congruent modulo <i>r</i> and then treat that set as a single mathematical object.</p>

<p><a href="relazioni.html#equivalence_class">Equivalence classese</a> are known as <b>congruence classes</b> modulo <i>n</i>

<p><b>Definition 4.2.0</b>. Given an integer <i>a</i>, we shall denote by [<i>a</i>]<sub><i>n</i></sub>, or, if no confusion may possibly arise, by [<i>a</i>], or by ā, the congruence class of <i>a</i> modulo <i>n</i>, that is,</p>

<div class="eq">
<p>[<i>a</i>]<sub><i>n</i></sub> = {<i>b</i> ∈ ℤ | <i>b</i> ≡<sub><i>n</i></sub> <i>a</i>} = {<i>a + hn</i> | <i>h</i> ∈ ℤ } = {..., <i>a −2n, a −n, a, a + n, a + 2n</i>, ...}.</p>
</div>

<p>i.e.: "congruent integers to <i>a</i> modulo <i>n</i>" are those that may written in the form <i>a + nh</i> for a particular <i>h</i> ∈ ℤ. Indeed, if <i>b ≡<sub><i>n</i></sub> a</i> thus <i>b − a</i> is a multiple of <i>n</i>, so <i>b − a = nh</i> for a particular <i>h</i> ∈ ℤ, i.e.: <i>b = a + nh</i>. This is the reason why equivalence classes modulo <i>n</i> are also called <b>residue classes</b> modulo <i>n</i>.</p>

<p><b>Theorem 4.2.1</b>. <i>a ≡ c</i> (mod <i>n</i>) if and only if [<i>a</i>] = [<i>c</i>].</p>

<p><b>Proof</b>. We must proove two things to meet the condition "if and only if"</p>

<ol>
	<li><p>If <i>a ≡ c</i> (mod <i>n</i>), then [<i>a</i>] = [<i>c</i>].</p></li>
	<li><p>If [<i>a</i>] = [<i>c</i>], the [<i>a</i>] = [<i>c</i>].</p></li>
</ol>

<p>We won't use the definition of congruence. Instead we use the fact that congruence is an equivalence relation hence reflexive, symmetric and transitive.</p>

<p>Assume first that <i>a ≡ c</i> (mod <i>n</i>). To prove that [<i>a</i>] = [<i>c</i>], we first show that [<i>a</i>] ⊆ [<i>c</i>]. To do this, let <i>b</b></i> &in; [<i>a</i>]. Then by definition <i>b ≡ a</i> (mod <i>n</i>). Since <i>a ≡ c</i> (mod <i>n</i>), we have <i>b ≡ c</i> (mod <i>n</i>) by transitivity. Therefore, <i>b</i> &in; [<i>c</i>] and [<i>a</i>] ⊆ [<i>c</i>]. Reversing the roles of <i>a</i> and <i>c</i> in this argument and using symmetry that is <i>c ≡ a</i> (mod <i>n</i>) is shown that [<i>c</i>] ⊆ [<i>a</i>]. Therefore, [<i>a</i>] = [<i>c</i>].</p>

<p>Conversely, assume that [<i>a</i>] = [<i>c</i>]. Since <i>a ≡ a</i> (mod <i>n</i>) by riflexivity, we have <i>a</i> &in; [<i>a</i>] and, hence, <i>a</i> &in; [<i>c</i>]. By definition of [<i>c</i>], we see that <i>a ≡ c</i> (mod <i>n</i>).□</p>

<p>If A and C are two sets, there are usually three possibilities: Either <i>A</i> and <i>C</i> are disjoint, or <i>A = C</i>, or <i>A ∩ C</i> is nonempty but <i>A &ne; C</i>. With congruence classes, however, there are only two possibilities:</p>

<p><b>Corollary 4.2.2</b>. Two congruence classes modulo <i>n</i> are either disjoint or identical.</p>

<p><b>Proof.</b> If [<i>a</i>] and [<i>c</i>] are disjoint, we are done. Suppose they are not, so [<i>a</i>] ∩ [<i>c</i>] is nonempty. Then there is an integer <i>b</i> with <i>b</i> &in; [<i>a</i>] and <i>b</i> &in; [<i>c</i>]. By definition of congruence class,  <i>b ≡ a</i> (mod <i>n</i>) and  <i>b ≡ c</i> (mod <i>n</i>). Therefore, by symmetry and transitivity, <i>a ≡ c</i> (mod <i>n</i>). Hence [<i>a</i>] = [<i>c</i>], by theorem 4.2.1, so if they are not disjoint they are identical.□</p>

<p><b>Corollary 4.2.3</b>. Let <i>n</i> &gt; 1 be an integer and consider congruence modulo <i>n</i></p>

<ol>
	<li><p>If <i>a</i> is any integer and <i>r</i> is the remainder when <i>a</i> is divided by <i>n</i>, then [<i>a</i>] = [<i>r</i>].</p></li>
	<li><p>There are exaclty <i>n</i> distinct congruences classes, namely [0], [1], [<i>n</i> − 1].</p></li>
</ol>

<p><b>Proof.</b> Let <i>a</i> &in;ℤ by the division algorithm dividing by <i>n</i>, <i>a = nq + r</i>, with <i>0 ≤ r &lt; n</i>. Thus <i>a − r = qn</i> 
so that <i>a ≡ r</i> (mod <i>n</i>). By theorem 4.2.1 [<i>a</i>] = [<i>r</i>]. The possible remainders are 0, 1, 2, ..., <i>n</i> − 1, that is there will be exaclty <i>n</i> equivalence classes.</p>

<p>To complete the proof, we must show that these <i>n</i> classes are all distinct. To do this, we first show that no two of 0, 1, 2, ... , <i>n</i> − 1 are congruent modulo <i>n</i>. Suppose that <i>s</i> and <i>t</i> are distinct integers in the list 0, 1 , 2, ..., <i>n</i> − 1. Then one is larger than the other, say <i>r</i>, so that <i>0 &le; s &lt; t &lt; n</i>. Consequently, <i>t − s</i> is a positive integer that is less than n. Hence, <i>n</i> does not divide <i>t − s</i>, which means that <i>t &ne; s</i>. Thus, no two of 0, 1, 2, ... , <i>n</i> − 1 are congruent modulo n. Therefore, by Theorem 4.2.1, the classes [0], [1], [2], ... , [<i>n</i> − 1] are all distinct.□</p>

<div class="def">
<p><b>Note</b>: There are several points to be careful about here. The elements of ℤ<sub><i>n</i></sub> are <i>classes</i>, not single integers. So the statement [5] &in; ℤ<sub><i>n</i></sub> is true, but the statement 5 &in; ℤ<sub><i>n</i></sub>, is not. Furthermore, every element of ℤ<sub><i>n</i></sub> can be denoted in many different ways. For example, we know that</p>

<div class="eq">
<p>2 ≡ 5 (mod 3) &emsp;&emsp; 2 ≡ −1 (mod 3) &emsp;&emsp; 2 ≡ 14 (mod 13)</p>
</div>

<p>Therefore, by Theorem 4.2.1, [2] = [5] = [− 1] = [14] in ℤ<sub>3</sub>.</p>

<p>For every integer <i>a</i> &in; ℤ there is a congruence class [<i>a</i>] &in; ℤ<sub>n</sub>. Even though each element of ℤ<sub><i>n</i></sub> (that is, each congruence class) <b>has infinitely many different labels</b>, there are only finitely many distinct classes by Corollary 4.2.3, which says in effect that</p>

<div class="eq">
<p>The set ℤ<sub><i>n</i></sub> has exactly <i>n</i> elements.</p>
</div>

<p>For example, the set ℤ<sub>3</sub> consists of the three elements [0], [1], [2]. The elements [3], [4], [5], ... are just repetitions of [0], [1], [2], ....</p>

</div>

<div class="def">
<p><b>Definition 4.2.4</b>. An <b>equivalence class</b> modulo <i>n</i> is the set of all integers having the same remainder upon division by the modulus <i>n</i>.</p>

<ul>
	<li><p>[0] = {integers that, divided by <i>n</i>, give a remainder equal to 0} = {<i>kn</i> | <i>k</i> ∈ ℤ} = {multiples of <i>n</i>};</p></li>
	<li><p>[1] = {integers that, divided by <i>n</i>, give a remainder equal to 1} = {<i>kn</i> + 1  | <i>k</i> ∈ ℤ}</p></li>
	<li><p>[2] = {integers that, divided by <i>n</i>, give a remainder equal to 1 =  {<i>kn</i> + 2 | <i>k</i> ∈ ℤ}</p></li>
	<li><p>[<i>n</i> − 1] = {integers that, divided by <i>n</i>, give a remainder equal to <i>n</i> − 1} =  {<i>kn + n</i> − 1 | <i>k</i> ∈ ℤ}.</p></li>
</ul>
</div>

<p><p>The set [<i>a</i>] contains all integers which yield the same remainder as the number <i>a</i> when divided by <i>n</i>. As we may always divide an integer <i>a</i> by <i>n</i> (see <a href="gcd.html#divisionZ">Proposition 2.15</a>), if we denote by <i>r</i> the remainder of the division, we immediatly obtain that all numbers in [<i>a</i>] are therefore congruent to <i>a</i> modulo <i>n</i>.</p>

<p><p>If <i>n</i> = 2, we only two possible remainder, 0 and 1 and consequently two classes, [0] e [1]: the first contains all integers {<i>2k</i> | <i>k</i> ∈ ℤ} the second all integers <i>2k</i> + 1 | <i>k</i> ∈ ℤ }, i.e. the <a href="relazioni.html#partizione">partition</a> induced on ℤ is that of even and odd numbers.</p>

<p>For example the class [2]<sub>9</sub> is made by integers of the form 2 + 9<i>h</i> for <i>h</i> ∈ ℤ equal to 0, 1, 2, 3, etc. we have thus 2 = 2 + 9 · 0, 11 = 2 + 9 · 1, 20 = 2 + 9 · 2, 29 = 2 + 9 · 3, and so forth, for negative <i>h</i> we obtain −7 = 2 + 9 · (−1), −16 = 2 + 9 · (−2), −25 = 2 + 9 · (−3), and so on. We have thus:</p>

<div class="eq"> 
<p>[2]<sub>9</sub> = {... , −25, −16, −7, 2, 11, 20, 29, 38, ...};</p>
</div>

<p>possiamo visualizzare la classe di resto di 2 modulo 9 come l’insieme costituito dai numeri che incontriamo partendo da 2 ed percorrendo l’intera lista dei numeri interi facendo passi di lunghezza 9, sia nel verso positivo che in quello negativo. Le altri classi sono:</p>

<p>[0]<sub>9</sub> = ..., 0, 9, 18, 27, 36, ... ≡ 0 (mod 9)</br>
[1]<sub>9</sub> = ..., 1, 10, 19, 28, 37, ... ≡ 1 (mod 9)</br>
[2]<sub>9</sub> = ..., 2, 11, 20, 29, 38, ... ≡ 2 (mod 9)</br>
[3]<sub>9</sub> = ..., 3, 12, 21, 30, 39, ... ≡ 3 (mod 9)</br>
[4]<sub>9</sub> = ..., 4, 13, 22, 31, 40, ... ≡ 4 (mod 9)</br>
[5]<sub>9</sub> = ..., 5, 14, 23, 32, 41, ... ≡ 5 (mod 9)</br>
[6]<sub>9</sub> = ..., 6, 15, 24, 33, 42, ... ≡ 6 (mod 9)</br>
[7]<sub>9</sub> = ..., 7, 16, 25, 34, 43, ... ≡ 7 (mod 9)</br>
[8]<sub>9</sub> = ..., 8, 17, 26, 35, 44, ... ≡ 8 (mod 9)</br>
..</br>
[20]<sub>9</sub> = ..., 20, 29, 38, 46, 55, ... ≡ 20 (mod 9)</br>
..</br>
</p>

<p>Every number falls into one of the first nine groups, from [0]<sub>9</sub> to [8]<sub>9</sub> and no number falls into more than one group.</p>

<div class="eq">
<p><i>a ≡<sub>n</sub> b</i> &emsp;⇐⇒&emsp; [<i>a</i>]<sub><i>n</i></sub> = [<i>b</i>]<sub><i>n</i></sub></p>
</div>

<p><b>Definition 4.2.5</b>. The set of all residue classes (congruence classes) modulo <i>n</i> is denoted ℤ/<i>n</i>ℤ or  ℤ<sub><i>n</i></sub> (which is read ℤ mod <i>n</i>").</p>

<div class="eq">
<p>ℤ<sub><i>n</i></sub> = {[<i>a</i>]<sub><i>n</i></sub>: 0 &le; <i>a &le; n − 1</i>} = {[0]<sub><i>n</i></sub>, [1]<sub><i>n</i></sub>, [2]<sub><i>n</i></sub>, ..., [<i>n</i> − 1]<sub><i>n</i></sub>}</p>
</div>

<p>Thus, using the congruence relation modulo <i>n</i></p>

<div class="eq">
<p>we passed from the infinite set ℤ to the finite set ℤ<sub><i>n</i></sub>.</p>
</div>

<p>This passage from infinite to finite is often very useful, especially when calculations or checks are to be performed with a computer which, as is well known, only works with finitely many objects. The remainder of division of <i>a</i> by <i>n</i> is equal to the unique representative of the congruence class <i>a</i> modulo <i>n</i> in ℤ<sub><i>n</i></sub> namely <i>a</i> mod <i>n</i>. Then it is easily checked that the map</p>

<div class="eq">
<p>ℤ/nℤ<sub><i>n</i></sub>  &emsp; → &emsp; ℤ<sub><i>n</i></sub></br>
<p>[<i>a</i>] &emsp; ↦ &emsp; <i>a</i> mod <i>n</i></p>
</div>

<p>which assigns to each residue class [<i>a</i>] the least non-negative residue of <i>a</i> modulo <i>n</i>, is a bijections.</p>

<p>Notiamo anche che ciascuna delle classi di resto si può rappresentare in tanti (addirittura infiniti) modi diversi, ad esempio [2]<sub>6</sub> = [14]<sub>6</sub> = [6000002]<sub>6</sub>, (6000002 = 2 (mod 6)) quindi anche ℤ<sub><i>n</i></sub> si potrà descrivere in molti modi. Ad esempio,</p>

<div class="eq">
<p>ℤ<sub><i>n</i></sub> = {[1]<sub><i>n</i></sub>, [2]<sub><i>n</i></sub>, ..., [<i>n</i> − 1]<sub><i>n</i></sub> , [<i>n</i>]<sub><i>n</i></sub>},</p>
</div>

<section>
<a href="modulo.html">&#171; Modular congruence</a>
<a href="index.html">Index</a>
<a href="modular_arithmetic.html">Modular arithmetic &#187;</a>
</section>

</div>

</body>
</html>
